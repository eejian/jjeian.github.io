<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里内推Java一面题目]]></title>
    <url>%2F2019%2F08%2F20%2F%E9%9D%A2%E8%AF%95%2F%E9%98%BF%E9%87%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数据库 1. 使用mysql索引都有哪些原则？？索引什么数据结构？？B+tree 和 B tree 什么区别？？ 12345678910111213141516171819202122231、 对于查询频率高的字段创建索引；2、 对排序、分组、联合查询频率高的字段创建索引；3、 索引的数目不宜太多 原因：a、每创建一个索引都会占用相应的物理控件； b、过多的索引会导致insert、update、delete语句的执行效率降低；4、若在实际中，需要将多个列设置索引时，可以采用多列索引 如：某个表(假设表名为Student)，存在多个字段(StudentNo, StudentName, Sex, Address, Phone, BirthDate)，其中需要对StudentNo,StudentName字段进行查询，对Sex字段进行分组，对BirthDate字段进行排序，此时可以创建多列索引 index index_name (StudentNo, StudentName, Sex, BirthDate); #index_name为索引名 在上面的语句中只创建了一个索引，但是对4个字段都赋予了索引的功能。 创建多列索引，需要遵循BTree类型， 即第一列使用时，才启用索引。 在上面的创建语句中，只有mysql语句在使用到StudentNo字段时，索引才会被启用。 如: select * from Student where StudentNo = 1000; #使用到了StudentNo字段，索引被启用。 可以使用explain检测索引是否被启用 如:explain select * from Student where StudentNo = 1000;5、选择唯一性索引 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。6、尽量使用数据量少的索引 如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。7、尽量使用前缀来索引 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。8、删除不再使用或者很少使用的索引. 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响 1B+ tree树索引, B tree, 散列 2.Mysql有哪些存储引擎？？都有啥区别？？要详细？？ 1234InnoDB: 事务型存储引擎, 并且有较高的并发读取频率MEMORY： 存储引擎，存放在内存中，数据量小， 速度快Merge: ARCHIVE： 归档， 有很好的压缩机制 3.设计高并发系统数据库层面该如何设计？？ 数据库锁有哪些类型？？如何实现？？ 12341. 分库分表： 同样量的数据平均存储在不同数据库相同表（或不同表）中，减轻单表压力，如果还是很大，就可以每个库在分多张表，根据hash取值或者其他逻辑判断将数据存储在哪张表中2. 读写分离： 数据库原本就有主从数据库之分，查询在从服务器，增删改在主服务器， 3. 归档和操作表区分： 建一张归档表，将历史数据放入，需要操作的表数据单独存储4. 索引啊之类的创建，对于数据量很大，百万级别以上的单表，如果增删改操作不频繁的话， 可以创建bitMap索引，速度要快得多 123451. 共享锁：要等第一个人操作完，释放锁，才能操作2. 更新锁：解决死锁，别人可以读，但不能操作3. 排他锁：读写都被禁用4. 意向锁（xlock）： 对表中部分数据加锁，查询时，可以跳过5. 计划锁： 操作时，别的表连接不了这张表， 4.数据库事务有哪些？？ 12341. 原子性： 所有操作要么全部成功，要么全部失败2. 一致性： 例如转账，一个事务执行前和执行后必须一致3. 隔离性： 防止脏读， 重复读问题4. 持久性： 永久性提交数据库 5. Oracle常用函数有哪些？？ 1234567891011121314Concat: 字符串拼接， 或者 ||Instr: 指定字符串位置Length: 长度Trim: 去空格Lower: 小写Upper:大写Nvl: 判断空Replace: 替换Substr: 截取Floor: 向下取整To_number:To_char:To_date:Decode: 判断函数等等 6. Sql中哪些情况可能不会走索引？？ 123456781. 查询谓词没有使用索引的主要边界,换句话说就是select *，可能会导致不走索引2. 单键值的b树索引列上存在null值，导致COUNT(*)不能走索引。索引列存在空值3. 索引列上有函数运算，导致不走索引4. 隐式类型转换导致不走索引。5. 表的数据库小或者需要选择大部分数据，不走索引6. ！=或者&lt;&gt;(不等于），可能导致不走索引 7. 表字段的属性导致不走索引，字符型的索引列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式，8. 使用like, in 等， 可能导致不走索引 分库分表 1.如何设计可以动态扩容缩容的分库分表方案？？ 2.用过哪些分库表中间件， 有啥优缺点？？讲一下你了解的分库分表中间件的底层实现原理？？ 3.我现在有一个未分库分表的系统，以后系统需分库分表，如何设计，让未分库分表的系统动态切换到分库分表的系统上？？ 4.分布式事务知道么？ 你们怎么解决的？？ TCC ?? 那若吃醋先网络原因，网络连不通怎么办？？ 5.为什么要分库分表？？ 6.分布式寻址方式都有哪些算法？？ 知道一致性hash吗？？手写一下java实现代码？？你若userId取摸分片，那我要查一段连续时间里的数据怎么办？ 7.如何解决分库分表主键问题？？有什么实现方案？ 分布式缓存 1.Redis和memcheched 什么区别？？为什么单线程的redis比多线程的memched效率要高？？ 2.Redis有什么数据类型？？都在哪些场景下使用？？ 3.redis主从复制是怎么实现的？？Redis的集群模式是如何实现的？？redis的key是如何寻址的？？ 4.使用redis如何设计分布式锁， 使用zk可以么？？如何实现？？这两种那个效率更高？？ 5.知道redis的持久化么？？ 都有什么优缺点？？具体底层实现呢？？ 6.Redis过期策略都有哪些？？LRU??写一下java版本的代码？？ 分布式服务框架 1.说一下dubbo的实现过程？？注册中心挂了可以继续通信么？？ 2.Zk原理知道吗？Zk都可以干什么？？Paxos算法知道吗？？说一下原理和实现？？ 3.Dubbo支持哪些序列号协议？？Hessian？？说一下hession的数据结构？？PB知道吗？？为啥PB效率是最高的？？ 4.知道netty么？？Netty可以干嘛啊？？NIO, BIO, AIO都是什么啊？有什么区别么？ 5.Dubbo复制均衡策略和高可用策略都有哪些？？动态代理策略呢？？ 6.为什么要进行系统拆分啊？？拆分不用dubbo可以吗？？Dubbo和thrift什么区别？？ 7.Mq相关？ java基础相关 1. Hashcode相等，两个类相等么？？equals 呢？？ 相反呢？？ 123不一定相等，都不一定相当。 反过来（equals相同，hashcode相同，则类相同）可能成立Equals用来判断两个对象的值是否相等， ==用来判断两个对象的引用地址和值是否相等 2.介绍一下集合框架？？ 123分两种： Collection: 包含独立元素， 可以重复，无序的， 继承了iterable接口，有一个iterator方法返回迭代器对象， 相关接口有list, queue， setMap: 包含键值对的元素，key不重复，value允许重复， 实现接口TreeMap, HashMap, LinkedhashMap, concurrentHashMap, hasTable 3.Hashmap ， hashtable底层实现什么区别？？Hashtable 和concurrenthashMap呢？？ 1234hashmap非线程安全的，key和value可以接收nul值Hashtable线程安全的，不能接受null单线程下，hashmap比hashtable快得多concurrentHashMap融合了hashtable和hashmap的优点，写可以多线程写，并且是线程安全的，读线程不受限制 4.Hashmap 和treemap 什么区别？？底层数据结构是什么？？ 12Hashmap: 数组方式存储， 线程非安全，可存储null, 无序Treemap: 基于二叉树实现方式， 线程非安全，不允许null, 存入元素需实现comparable接口， 自定义排序规则。 5.线程池用过么？？都有什么参数？？底层如何实现的？？ 123456核心池大小线程池最大线程数保持多久时间会终止阻塞队列，存储等待执行的任务；Java通过Executors可以提供四种线程池 6.Sychnized和lock什么区别？？Sychnize 什么情况，情况下是对象锁？？什么时候是全局锁？？为什么？？ 12341.synchnized 是关键字，在方法出错之后由java虚拟机自动解除锁定，而 Lock属于Api级别的锁，它需要自己在 finally方法后面保证锁的释放。2.synchnized 不能实现公平锁，而 Lock可以，Lock还可以添加多个监听条件来对锁进行控制，可以中断。3.synchronized 作用在普通方法上属于对象锁，作用在静态方法，类.class 上面，属于全局锁。对象锁只对同一个对象加锁，作用对象是同一个对象。而类锁是对类加锁，对整个类都有效。 如果锁住的是一般方法就是对象锁，对象锁只会对同一个对象起作用，如果是锁住了static 方法则是全局锁，会对全局对象都管用，如果想在普通方法中使用全局锁需要锁住class对象。 7.ThreadLocal 是什么？？ 底层如何实现？？写一个例子呗？？ 12345678910ThreadLocal 底层是存储在 线程本地Map里面的一个对象，它跟当前线程绑定，以 ThreadLocal 对象本身为 key，以ThreadLocal里面存的值为值，目的是为了实现线程之间的数据的隔离。public static final ThreadLocal session = new ThreadLocal(); public static Session getCurrentSession() &#123; Session s = (Session)session.get(); if(s == null)&#123; s = sessionFactory.openSession(); session.set(s); &#125; return s; &#125; 8.Volitile的工作原理？？ 123456789实例化一个对象其实可以分为三个步骤： （1）分配内存空间。 （2）初始化对象。 （3）将内存空间的地址赋值给对应的引用。多线程情况下，Volitile修饰的变量会被加一个lock指令，这个指令做两件事情，1.在变量改变之后，会立刻从cpu高速缓存写到内存2.会通知其他cpu缓存中的该变量的值设置成无效，用到该变量时会到内存中重新读取该变量的值。Lock指令保证了缓存一致性原理 9.Cas知道么？？如何实现的？？ 12CAS（Compare and Swap）即比较并替换，实现并发算法时常用到的一种技术,三个参数，比较是否相等，当内存值和预期值相等时，才会将第三个值更新，并返回true 10.请用至少四种写法， 写一个单例模式呗？？ 1231. 实例静态类2. volitile修饰，sychnized修饰3. 枚举使用（推荐） JVM 1.请介绍一下jvm内存模型？？ 用过什么垃圾回收器？？ 都说说吧？？ 2.线上发送频繁full gc如何处理？？ cpu使用率过高怎么办？？ 如何定位问题？？如何解决？？说一下解决思路和处理方法？？ 3.知道字节码么？字节码都有哪些？Integer x =5 , int y = 5 , 比较x == y 都需要经过哪些步骤？？ 4.讲讲类加载机制呗？？都有哪些类加载器？？这写类加载器都加载哪些文件？？手写一下类加载demo?? 5.知道osgi么？？他是如何实现的？？ 6.请问你做过哪些JVM优化？？使用什么方法？？达到什么效果？？ 7.Class.forName(“java.lang.String”)和String.class.getClassLoader().loadClass(“java.lang.String”)有什么区别么？？ Spring 1.spring都有哪些机制？？AOP底层如何实现的？？IOC呢？？ 2.Cglib知道么？？他和jdk动态代理什么区别？？手写一个jdk动态代理吧？？ 分布式消息队列 1.为什么是用消息队列？？消息队列有什么优点和缺点？？ 2.如何保证消息队列的高可用性？？如何保证消息不被重复消费？？ 3.Kafka， activemq , rabbitmq, rocketmq 都有什么优缺点？？ 4.如果让你写一个消息队列， 该如何进行架构设计？？说一下你的思路 分布式搜索引擎 1.Es的工作过程实现是如何的？？ 如何实现分布式的？？ 2.Es在数据量很大的情况下（数十亿级别）如何提高查询效率？？ 3.Es的查询是一个怎么的工作过程？？底层lucence介绍一下？？倒排索引知道么？？Es和mongdb什么区别啊？？都在什么场景下使用啊？？ 高并发高可用架构设计 1.如何设计一个高并发高可用系统？？ 2.如何限流？？工程中怎么做的？？说一下具体实现？？ 3.缓存如何使用的？？缓存使用不当会造成什么后果？？ 4.如何熔断啊？？熔断框架都有哪些？？具体实现原理知道吗？？ 5.如何降级？？如何进行系统拆分？？如何数据库拆分？？ 通信协议 1.说一下TCP/IP四层？？ 2.http的工作流程？？http1.0, http1.1 , http2.0 具体哪些区别？？ 3.Tcp三次握手， 四层分手的工作流程??画一下流程图？？为什么不是四次五次或者二次啊？？ 4.画一下https的工作原理？？具体如何实现的，如何防止被抓包啊？？ 算法 1.比较简单， 我一个文件， 有45亿个阿拉伯数字， 如何进行去重啊？？如何找出最大的那个数啊？？ 数据结构 1.二叉树和红黑数等？？ java集合相关 请简要描述一下J2EE应用中的class loader的层次结构？ java1.7 和1.8中，hashmap的区别 mybatis一级缓存，二级缓存，缓存策略 osi七层网络模型，五层网络模型，每次层分别有哪些协议 死锁产生的条件， 以及如何避免死锁，银行家算法，产生死锁后如何解决 如何判断链表有环 虚拟机类加载机制，双亲委派模型，以及为什么要实现双亲委派模型 虚拟机调优参数 拆箱装箱的原理 JVM垃圾回收算法 CMS G1 hashset和hashmap的区别，haspmap的底层实现put操作，扩容机制，currenthashmap如何解决线程安全,1.7版本以及1.8版本的不同md5加密的原理 有多少种方法可以让线程阻塞，能说多少说多少 synchronized和reetrantlock锁 AQS同步器框架，countdowmlatch，cyclebarrier，semaphore，读写锁 阿里内推Java二面题目 B-Tree索引，myisam和innodb中索引的区别 BIO和NIO的应用场景 讲讲threadlocal 数据库隔离级别，每层级别分别用什么方法实现，三级封锁协议,共享锁排它锁，mvcc多版本并发控制协议，间隙锁 数据库索引？B+树？为什么要建索引？什么样的字段需要建索引，建索引的时候一般考虑什么？索引会不会使插入、删除作效率变低，怎么解决？ 数据库表怎么设计的？数据库范式？设计的过程中需要注意什么？ 共享锁与非共享锁、一个事务锁住了一条数据，另一个事务能查吗？ Spring bean的生命周期？默认创建的模式是什么？不想单例怎么办？ 阿里内推Java三面题目 高并发时怎么限流 线程池的拒接任务策略 springboot的启动流程 集群、负载均衡、分布式、数据一致性的区别与关系 数据库如果让你来垂直和水平拆分，谁先拆分，拆分的原则有哪些(单表数据量多大拆) 最后谈谈Redis、Kafka、 Dubbo，各自的设计原理和应用场景 6，唤醒一个阻塞的线程 如因为Sleep，wait，join等阻塞，可以使用interrupted exception异常唤醒。 8，redis使用单线程模型，数据顺序提交，redis支持主从模式，mencache只支持一致性hash做分布式；redis支持数据落地，rdb定时快照和aof实时记录操作命令的日志备份，memcache不支持；redis数据类型丰富，有string，hash，set，list， sort set，而memcache只支持简单数据类型；memcache使用cas乐观锁做一致性。 9，Class.forName()将类加载到JVM，还会对类解释，执行static块，而ClassLoader也加载到JVM，但是不会执行static块，并且只有调用了new Instance方法才会调用构造函数。 10，java反射机制。 可以在运行时判断一个对象所属的类，构造一个类的对象，判断类具有的成员变量和方法，调用1个对象的方法。4个关键的类：Class，Constructor，Field，Method。 getConstructor获得构造函数/getDeclardConstructor； getField/getFields/getDeclardFields获得类所生命的所有字段；getMethod/getMethods/getDeclardMethod获得类声明的所有方法，正常方法是一个类创建对象，而反射是1个对象找到1个类。 11，Object类中的方法：clone()，但是使用该方法必须实现Java.lang.Cloneable接口，equal()方法判断引用是否一致，指向同一对象，即相等于==，只有覆写了equals()方法之后，才可以说不同。hashcode()，对象的地址， toString()， finalize()。 12，序列化和反序列化 序列化和反序列化即对象和字节序列间的转化，进程间传送文本图片音频等以二进制传送。JDK中ObjectOuputStream和ObjectInputStream为输出输入流，只有实现SeriaLizable/Externalizable接口的类才能被序列化。如Person对象传递给内存流使用DataConstractJsonSeralizer， MemoryStream stream = new MemoryStream(); DataConstractJsonSeralizer SER = new DataConstractJsonSeralizer(typeof(person)); ser.writeObjectStream(stream, person);显示json输出，StramReader sr = new StreamReader(stream1); sr.ReadToEnd()。 13，讲讲分布式唯一ID。 确定ID存储用64位，1个64位二进制1是这样的00000000…1100…0101，切割64位，某段二进制表示成1个约束条件，前41位为毫秒时间，后紧接9位为IP，IP之后为自增的二进制，记录当前面位数相同情况下是第几个id，如现在有10台机器，这个id生成器生成id极限是同台机器1ms内生成2的14次方个ID。 分布式唯一ID = 时间戳 &lt;&lt; 41位， int类型服务器编号 &lt;&lt; 10，序列自增sequence。每个时间戳内只能生成固定数量如（10万）个自增号，达到最大值则同步等待下个时间戳，自增从0开始。将毫秒数放在最高位，保证生成的ID是趋势递增的，每个业务线、每个机房、每个机器生成的ID都是不同的。如39bit毫秒数|4bit业务线|2bit机房|预留|7bit序列号。高位取2016年1月1日1到现在的毫秒数，系统运行10年，至少需要10年x365天x24小时x3600秒x1000毫秒=320x10~9，差不多39bit给毫秒数，每秒单机高峰并发小于100，差不多7bit给每毫秒的自增号，5年内机房小于100台机器，预留2bit给机房，每个机房小于100台机器，预留7bit给每个机房，业务线小于10个，预留4bit给业务线标识。 64bit分布式ID（42bit毫秒+5bit机器ID+12位自增）等 生成分布式ID的方式：A，2个自增表，步长相互隔开 B，时间的毫秒或者纳秒 C，UUID D，64位约束条件（如上） 14，NIO和IO的区别 第一点，NIO少了1次从内核空间到用户空间的拷贝。 ByteBuffer.allocateDirect()分配的内存使用的是本机内存而不是Java堆上的内存，和网络或者磁盘交互都在操作系统的内核空间中发生。allocateDirect()的区别在于这块内存不由java堆管理, 但仍然在同一用户进程内。 第二点，NIO以块处理数据，IO以流处理数据 第三点，非阻塞，NIO1个线程可以管理多个输入输出通道 15，内存泄漏 未对作废数据内存单元置为null，尽早释放无用对象的引用，使用临时变量时，让引用变量在推出活动域后自动设置为null，暗示垃圾收集器收集；程序避免用String拼接，用StringBuffer，因为每个String会占用内存一块区域；尽量少用静态变量（全局不会回收）；不要集中创建对象尤其大对象，可以使用流操作；尽量使用对象池，不再循环中创建对象，优化配置；创建对象到单例getInstance中，对象无法回收被单例引用；服务器session时间设置过长也会引起内存泄漏。 16，对象克隆和实现方式 克隆的对象可能包含一些已经修改过的属性，而new1个对象属性都还是初始化时候的值，被复制克隆的类要实现Clonable接口，覆盖clone()方法，访问修饰符为public，方法中调用super.clone()得到所需要的复制方法，类中的属性类也需要实现Clonable接口，覆写clone()方法，并在super中也调用子属性类的clone()复制，才可以实现深拷贝。 或者写到流中序列化的方式来实现，不必考虑引用类型中还包含引用类型，直接用序列化来实现对象的深复制拷贝，即将对象写到流，再从流中读出来，需要实现seriazation接口。 17，redis内存数据上升到一定大小会执行数据淘汰策略，redis提供了6种数据淘汰策略。 LRU：从已设置过期时间的数据集合中挑选最近最少使用的数据淘汰 random：从已设置过期时间的数据中挑选任意数据淘汰 ttl：从已设置过期时间的数据集合中挑选将要过期的数据淘汰。 notenvision：禁止驱逐数据 如mysql中有2千万数据，redis只存储20万的热门数据。LRU或者TTL都满足热点数据读取较多，不太可能超时特点。 redis特点：速度块，O(1)，丰富的数据类型，支持事物原子性，可用于缓存，比memecache速度块，可以持久化数据。 常见问题和解决：Master最好不做持久化如RDB快照和AOF日志文件；如果数据比较重要，某分slave开启AOF备份数据，策略为每秒1次，为了主从复制速度及稳定，MS主从在同一局域网内；主从复制不要用图状结构，用单向链表更为稳定 M-S-S-S-S。。。。；redis过期采用懒汉+定期，懒汉即get/set时候检查key是否过期，过期则删除key，定期遍历每个DB，检查制定个数个key；结合服务器性能调节并发情况。 过期淘汰，数据写入redis会附带1个有效时间，这个有效时间内该数据被认为是正确的并不关心真实情况，例如对支付等业务采用版本号实现，redis中每一份数据都维持1个版本号，DB中也维持1份，只有当redis的与DB中的版本一致时，才会认为redis为有效的，不过仍然每次都要访问DB，只需要查询version版本字段即可。 18，异步化，生产接口每秒钟10万并发，消费者用异步慢慢消费。缓存模式空间换时间，把1两亿的数据名单打到缓存。服务降级，把不重要的任务放弃；静态资源离线包下载机制，在wify下会主动提前把静态下载前端层保护可请将用户请求延长，点击后主动给它随机等待2s的时间/2分钟之内不能请求；后端做部分接口的开关，设置超短耗时时间，原来只用5ms的只给20ms。 系统一段时间内会自动重试，重试多次后就认为是失败了，检查支付接口返回该订单的钱，支付操作如果回复错误则回滚扣库存的事务，没返回则会记录进行中pendding状态，结束整个过程，等通知失败/成功，AB系统之间会出现死循环补偿，如B退单不成功，一般就是记录错误日志了。超时每隔一段时间去定时回调服务定时回滚，一定次数还是超时则提示用户联系客服，订单库存可以不会滚，记录状态，如果一直调用支付不成功，则让用户自己去处理联系客服，可以不回滚用户的数据，金额扣了才算真正完成，是一种简单粗暴的做法。 公共配置抽象成存储到zookeeper配置中心或者redis等，DB也存储一份，各应用监听ZK的配置变化，可以建一个配置web管理页面。 19，dubbo用ProxyFactoty代理工厂将HelloServiceImpl封装成1个Inoke执行，即ProxyFactory.getInvoke(ref, (Class)接口，注册URL，解码参数)，并将Invoke导出成1个Exporter，包括去注册中心ZK注册服务。Invoke有本地执行的Invoke，远程通信执行的Invoke。 20，每次扣减库存时加上1个请求流水编号，上层请求扣减库存没拿到结果的话，重新查询1次做重试操作，量不大都是加锁处理。减少锁的时间，牺牲幂等性，扣减为DB下地操作，查询扣减和设置合成1步，中间没有网络请求。利用缓存，通过写log记录操作，异步合并日志及更新，重启时cache失效，读log恢复，避免重复提交，写操作不建议重试快速失败。多个商品同时增减库存，可使用订单号做幂等处理，应用层对单个商品减库存，操作排队，商品消息ID路由在1个应用server处理，读本地缓存，失效再redis，DB采用乐观锁，组提交，1次减库存多个订单的购买量。可将同一个key下库存m分为n组k1…kn，每组数为m/n，扣减依次在各组扣减，减少并发冲突。队列装满后关闭队列进入，然后用户轮训自己是否抢到了异步ajax，用户资源队列固定长度。2个队列，1个销售的资源队列放入redis，有另外1个队列用来装抢购的会员的uid。 红包状态正常，并成功将状态改为“已领取”，且消息发送成功，用户端开始消费该消息，如果消费失败/超时，用MQ做重试做幂等，直到成功，每条消息有唯一编号且保证消息处理成功与去重表的日志同时出现。 热点将hot data拆分，分在不同库和不同表，分散热点Data，减轻DB并发更新热点带来RT升高和应用连接超时。SQL在mysql层加以限制，SQL超时/thradrunning到1定值则拒绝SQL执行，一定时间异步将结果写入DB，nginx对IP做限制，可能误杀。 21，SpringAOP，XML配置aop:config，切面aop:aspect切点aop:pointcut，连接切点和通知方法aop:before和aop:after等，注解可以直接使用@before执行方法@after ，@before(“pointcut()”) ，@after(“pointcut”)， @Aroud(&quot;excutete())，@AfteReturning，@AfterThrowing，可作日志事务，权限等待，AOP即通过把具体的类创建对应的 代理类，从代理类来对具体进行操作。 目标实现了接口，默认采用JDK实现AOP，也可以强制使用CGlib来实现AOP，目标没有实现接口的话，则必须采用CGlib，Spring自动在JDK和CGlib切换。如果要求spring强制使用CGlib实现AOP，则可以配置，添加Cglib库。。。jar， Spring配置文件中加入&lt;aop:aspecj-autoproxy proxy-target-Class=true&gt; 22，MyISM采用表级锁，对Myism表读不会阻塞读，会阻塞同表写，对Myism写则会阻塞读和写，即一个线程获得1个表的写锁后，只有持有锁的线程可以对表更新操作，其他线程的读和写都会等待。 InnoDB，采用行级锁，支持事务，例如只对a列加索引，如果update …where a=1 and b=2其实也会锁整个表， select 使用共享锁，update insert delete采用排它锁，commit会把锁取消，当然select by id for update也可以制定排它锁。 23，实时队列采用双队列模式，生产者将行为记录写入Queue1，worker服务从Queue1消费新鲜数据，如果异常则写入Queue2（主要保存异常数据），RetryWorker会监听Queue2，消费异常数据，如果还未处理成功按照一定的策略等待或者将异常数据再写入Queue2，如果数据发生积压可以调整worker的消费游标，从最新数据重新开始消费，保证了最新data得到处理，中间未处理的一段则可以启动backupWorker指定起止游标在消费完指定区间的数据后，backupWorker会自动停止。 DB降级开关后，可直接写入redis（storm），同时将数据写入一份到Retry队列，在开启DB降级开关后消费Retry队列中的数据，从而把数据写入到mysql中，达到最终一致性。MYSQL切分为分片为2的N次方，例如原来分为两个库d0和d1均放在s0服务器上，s0同时有备机s1，扩容只要几步骤：确保s0到s1服务器同步顺利，没有明显延迟；s0暂时关闭读写权限；确保s1已经完全同步到s0更新；s1开放读写权限；d1的dns由s0切换到s1；s0开放读写权限。 24，DB的特性和隔离级别 4大特性：原子性，一致性，分离性，持久性 隔离级别： 读提交：写事务禁止读 读未提交：写事务允许读 可重复读：写事务禁止读事务，读禁止写 序列化：全部禁止 详细说明：读提交1个事务开始写则全部禁止其他事务访问该行。读未提交1个事务开始写则不允许其他事务同时写，但可以读。可重复读 读事务会禁止写事务，写事物则禁止其他任何事务。序列化性能最低，全部禁止，串行执行。 MYSQL默认的是可重复读。 25，帖子服务、元数据服务、帖子搜索服务，提供索引数据存储，tid和uid查询直接从帖子服务从元数据返回，其他检索查询有帖子搜索服务从索引数据检索并返回，帖子服务增删改查用MQ同步到帖子搜索服务，搜索服务修改索引的数据（索引树，倒排表），索引表t_mapping（tid，uid）。 300亿数据在全量索引库中，数百万一天内修改过的数据在一天库中，50万小时内修改过的数据在小时库中，在update请求时，只会操作最低级别的索引例如小时库。小时库，1小时合并一次，合并到天库，天库一天合并1次，合并到全量库中。 26，讲一下NIO和网络传输 NIO Reactor反应器模式，例如汽车是乘客访问的实体reactor，乘客上车后到售票员处Acceptor登记，之后乘客便可休息睡觉了，到达乘客目的地后，售票员Aceptor将其唤醒即可。持久TCP长链接每个client和server之间有存在一个持久连接，当CCU（用户并发数量）上升，阻塞server无法为每个连接运行1个线程，自己开发1个二进制协议，将message压缩至3-6倍，传输双向且消息频率高，假设server链接了2000个client，每个client平均每分钟传输1-10个message，1个messaged的大小为几百字节/几千字节，而server也要向client广播其他玩家的当前信息，需要高速处理消息的能力。Buffer，网络字节存放传输的地方，从channel中读写，从buffer作为中间存储格式，channel是网络连接与buffer间数据通道，像之前的socket的stream。 27，缓存击透 预加载； 加载DB时同步，其他则等待； DB端做SQL合并，Queue合并排队处理； 部分缓存设置为永不过期； 先清除缓存，读取数据时候则等待500ms，500ms缓存应该已经加载完成； 采用双key缓存，A1为原始缓存，A2为拷贝缓存； 如果DB为空null则g给redis设置1个NFC空nei容。 28，Dubbo源码使用了哪些设计模式 A，工厂模式，ExtenstionLoader.getExtenstionLoader(Protocol.class).getAdaptiveExtenstion() B，装饰器模式+责任链，以provider的调用链为例，具体调用链代码是在protocolFilterWrapper的buildInvokeChain完成的,将注解中含有group=provider的Filter实现，调用顺序为EchoFilter -&gt; ClassLoaderFilter -&gt; GenericFilter -&gt; ContextFilter -&gt; ExceptionFilter -&gt; TimeoutFilter -&gt; MonitorFilter -&gt; TraceFilter。装饰器模式和责任链混合使用，Echo是回声测试请求，ClassLoaderFilter则只是在其主功能上添加了功能。 C，观察者模式，provider启动时需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时采用了观察者模式，注册中心每5s定时检查是否有服务更新，有更新则向服务提供者发送1个notify消息后即可运行NotifyListener的notity方法，执行监听器方法。 D，动态代理模式。 扩展JDK的ExtensionLoaderdeAdaptive实现，根据调用阶段动态参数决定调用哪个类，生成代理类的代码是ExtensionLoader的createAdaptiveExtenstionClassLoader方法。 29，平衡二叉树，左右高度之差不超过1，Add/delete可能造成高度&gt;1，此时要旋转，维持平衡状态，避免二叉树退化为链表，让Add/Delete时间复杂度但控制在O(log2N)，旋转算法2个方法，1是求树的高度，2是求2个高度最大值，1个空树高度为-1，只有1个根节点的树的高度为0，以后每一层+1，平衡树任意节点最多有2个儿子，因此高度不平衡时，此节点的2棵子树高度差为2。例如单旋转，双旋转，插入等。 红黑树放弃完全平衡，追求大致平衡，保证每次插入最多要3次旋转就能平衡。 30，多线程同步锁 A，RentrantLock，可重入的互斥锁，可中断可限时，公平锁，必须在finally释放锁，而synchronize由JVM释放。可重入但是要重复退出，普通的lock()不能响应中断，lock.lockInterruptbly()可响应中断，可以限时tryLock()，超时返回false，不会永久等待构成死锁。 B，Confition条件变量，signal唤醒其中1个在等待的线程，signalall唤醒所有在等待的线程await()等待并释放锁，与lock结合使用。 C，semaphore信号量，多个线程比（额度=10）进入临界区，其他则阻塞在临界区外。 D，ReadWriteLock，读读不互斥，读写互斥，写写互斥。 E，CountDownLantch倒数计时器，countdown()和await() F，CyCliBarrier G，LockSupport，方法park和unpark 31，栈溢出的原因 是否递归的调用；大量循环；全局变量是否过多；数组，List，Map数据是否过大；用DDMS工具检查地方。 内存溢出的原因 过多使用了static；static最好只用int和string等基本类型；大量的递归或者死循环；大数据项的查询，如返回表的所有记录，应该采用分页查询。检查是否有数组、List、map中存放的是对象的引用而不是对象，这些引用会让对应对象不能被释放。 栈过大会导致内存占用过多，频繁页交换阻碍效率。 32，说一下http/2 Http/2采用二进制格式而不是文本 Http/2是完全多路复用的，而非有序并阻塞的。 Http/2使用报头压缩 Http/2让服务器可以将响应主动推送到客户端缓存中。 33，说一下内存泄露 A，HashMap,vector等容易（静态集合类）， 和应用程序生命周期一样，所引用的所有对象Object也不能释放。 B，当集合类里面的对象属性被修改后，再调用remove()不起作用，hashcode值发生了改变 C，其对象add监听器，但是往往释放对象时忘记去删除这些监听器 D，各种连接记得关闭 E，内部类的引用 F，调用其他模块，对象作用参数 G，单例模式，持有外部对象引用无法收回。 内存泄露例子 Vector A = new Vector(); for(int i = 0; i &lt; 100; i++){ Object o = new Object (); A.add(o); o = null; } … 内存溢出的例子 StringBuffer b = new StringBuffer (); for(int i =0; i &lt; 100; i++){ for(int j =0; i &lt; 100; j++){ b.append(*); } } 34，SpirngMVC的生命周期 和 SpringBean的生命周期 SpirngMVC的生命周期 ： A，DispatcherSerlvet（前端控制器） B，-》 HandlerMapping（处理器映射器），根据xml注解查找对应的Hander -》 返回Handler C，-》处理器适配器去执行Handler D，-》Handler执行完成后给处理器适配器返回ModelAndView E，-》前端控制器请求视图解析器去执行视图解析，根据逻辑视图名解析成真正的视图JSP，向前端控制器返回view F，-》前端控制器进行视图渲染，将模型数据放到request-》返回给用户 SpringBean的生命周期： Instance实例化-》设置属性值-》调用BeanNameAware的setBeanName方法-》调用BeanPostProsessor的预初始化方法-》调用InitializationBean的afterPropertiesSet()的方法-》调用定制的初始化方法callCustom的init-method-》调用BeanPostProsessor的后初始化方法-》Bean可以使用了 -》 容器关闭-》 调用DisposableBean的destroy方法-》调用定制的销毁方法CallCustom的destroy-method。 35，AQS，抽象队列同步器 AQS定义2种资源共享方式：独占与share共享 独占：只能有1个线程运行 share共享：多个线程可以同p执行如samphore/countdownlanch AQS负责获取共享state的入队和/唤醒出队等，AQS在顶层已经实现好了，AQS有几种方法：acquire()是独占模式下线程共享资源的顶层入口，如获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止。tryAcquire()将线程加入等待队列的尾部，并标志为独占。acquireQueued()使线程在等待队列中获取资源，一直到获取资源后不返回，如果过程被中断也返回true，否则false。 线程在等待过程中被中断是不响应的，获取资源才补上中断。将线程添加到队列尾部用了CAS自旋（死循环直到成功），类似于AutomicInteger的CAS自旋volatile变量。 start-&gt;tryAcquire -&gt; 入队 -&gt; 找安全点 -&gt; park等待状态 -&gt; 当前节点成对头 -&gt; End 36，单例模式的7种写法 懒汉2种，枚举，饿汉2种，静态内部类，双重校验锁（推荐）。 37，lucence倒排索引 三个文件：字典文件，频率文件，位置文件。词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。 field的概念，用于表达信息所在位置（如标题中，文章中，url中），在建索引中，该field信息也记录在词典文件中，每个关键词都有一个field信息(因为每个关键字一定属于一个或多个field)。 关键字是按字符顺序排列的（lucene没有使用B树结构），因此lucene可以用二元搜索算法快速定位关键词。 假设要查询单词 “live”，lucene先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果。词典通常非常小，因而，整个过程的时间是毫秒级的。 对词典文件中的关键词进行了压缩，关键词压缩为&lt;前缀长度，后缀&gt;，例如：当前词为“阿拉伯语”，上一个词为“阿拉伯”，那么“阿拉伯语”压缩为&lt;3，语&gt;。对数字的压缩，数字只保存与上一个值的差值。 38，ZooKeeper分布式高可用 ZooKeeper 运行期间，集群中至少有过半的机器保存了最新数据。集群超过半数的机器能够正常工作，集群就能够对外提供服务。 zookeeper可以选出N台机器作主机，它可以实现M:N的备份；keepalive只能选出1台机器作主机，所以keepalive只能实现M:1的备份。 通常有以下两种部署方案：双机房部署（一个稳定性更好、设备更可靠的机房，这个机房就是主要机房，而另外一个机房则更加廉价一些，例如，对于一个由 7 台机器组成的 ZooKeeper 集群，通常在主要机房中部署 4 台机器，剩下的 3 台机器部署到另外一个机房中）；三机房部署（无论哪个机房发生了故障，剩下两个机房的机器数量都超过半数。在三个机房中都部署若干个机器来组成一个 ZooKeeper 集群。假设机器总数为 N，各机房机器数：N1 = (N-1)/2 ，N2=1~(N-N1)/2 ，N3 = N - N1 - N2 ）。 水平扩容就是向集群中添加更多机器，Zookeeper2种方式（不完美），一种是集群整体重启，另外一种是逐台进行服务器的重启。 39，如何将数据分布在redis第几个库？ 答：redis 本身支持16个数据库，通过 数据库id 设置，默认为0。 例如jedis客户端设置。一：JedisPool(org.apache.commons.pool.impl.GenericObjectPool.Config poolConfig, String host, int port, int timeout, String password, int database); 第一种通过指定构造函数database字段选择库，不设置则默认0库。二：jedis.select(index);调用jedis的select方法指定。 40，类加载器的双亲委派加载机制？ 答：当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 41，kafka高性能的原因？ 答： A，Broker NIO异步消息处理，实现了IO线程与业务线程分离； B，磁盘顺序写； C， 零拷贝（跳过用户缓冲区的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到用户态缓冲区）； D，分区/分段（每次文件操作都是对一个小文件的操作，非常轻便，同时也增加了并行处理能力）； F，批量发送 (可以指定缓存的消息达到某个量的时候就发出去，或者缓存了固定的时间后就发送出去，大大减少服务端的I/O次数) E，数据压缩 42，幂等的处理方式？ 答：一、查询与删除操作是天然幂等 二、唯一索引，防止新增脏数据 三、token机制，防止页面重复提交 四、悲观锁 for update 五、乐观锁（通过版本号/时间戳实现， 通过条件限制where avai_amount-#subAmount# &gt;= 0） 六、分布式锁 七、状态机幂等（如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。） 八、select + insert（并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行） 43，HTTPS工作流程？ a、客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了 b、服务器从中选出一套加密算法和hash算法以及自己的身份信息(地址等)以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构 c、客户端收到网站的证书之后要做下面的事情： c1、验证证书的合法性 c2、如果验证通过证书，浏览器会生成一串随机数作为密钥K，并用证书中的公钥进行加密 c3、用约定好的hash算法计算握手消息，然后用生成的密钥K进行加密，然后一起发送给服务器 d、服务器接收到客户端传送来的信息，要求下面的事情： d1、用私钥解析出密码，用密码解析握手消息，验证hash值是否和浏览器发来的一致 d2、使用密钥加密消息，回送 如果计算法hash值一致，握手成功 44，RabbitMQ消息堆积怎么处理？ 答： 增加消费者的处理能力(例如优化代码)，或减少发布频率 单纯升级硬件不是办法，只能起到一时的作用 考虑使用队列最大长度限制，RabbitMQ 3.1支持 给消息设置年龄，超时就丢弃 默认情况下，rabbitmq消费者为单线程串行消费，设置并发消费两个关键属性concurrentConsumers和prefetchCount，concurrentConsumers设置的是对每个listener在初始化的时候设置的并发消费者的个数，prefetchCount是每次一次性从broker里面取的待消费的消息的个数 建立新的queue，消费者同时订阅新旧queue 生产者端缓存数据，在mq被消费完后再发送到mq 打破发送循环条件，设置合适的qos值，当qos值被用光，而新的ack没有被mq接收时，就可以跳出发送循环，去接收新的消息；消费者主动block接收进程，消费者感受到接收消息过快时主动block，利用block和unblock方法调节接收速率，当接收线程被block时，跳出发送循环。 新建一个topic，partition是原来的10倍；然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue；接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据；等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息； 45，RabbitMQ的消息丢失解决方案？ 答： 消息持久化：Exchange 设置持久化：durable:true；Queue 设置持久化；Message持久化发送。 ACK确认机制：消息发送确认；消息接收确认。 46，负载均衡算法？ 常见6种负载均衡算法：轮询，随机，源地址哈希，加权轮询，加权随机，最小连接数。 nginx5种负载均衡算法：轮询，weight，ip_hash，fair（响应时间），url_hash dubbo负载均衡算法：随机，轮询，最少活跃调用数，一致性Hash 47，JVM内存区域划分？ 答： 堆：Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的），是Java垃圾收集器管理的主要区域。堆是被所有线程共享的，在JVM中只有一个堆。 虚拟机栈：虚拟机栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表、操作数栈、指向当前方法所属的类的运行时常量池的引用、方法返回地址和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。 本地方法栈：本地方法栈则是为执行本地方法（Native Method）服务的，在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一 方法区：方法区与堆一样，是被线程共享的区域。方法区存储了类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。当方法区无法满足内存分配需求时，则抛出OutOfMemoryError异常。在HotSpot虚拟机中，用永久代来实现方法区，将GC分代收集扩展至方法区，但是这样容易遇到内存溢出的问题。JDK1.7中，已经把放在永久代的字符串常量池移到堆中。JDK1.8撤销永久代，引入元空间。 程序计数器（线程私有）：是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native方法，则为空。 直接内存：在JDK1.4中新加入的NOI类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 48，jvm YGC和FGC发生的具体场景？ 答： 正在处理的实现事务功能，下次自动回滚。 队列实现持久化储存，下次启动自动载入。 添加标志位，未处理 0，处理中 1，已处理 2。每次启动的时候，把所有状态为 1 的，置为 0。 关键性的应用就给电脑配个 UPS。 YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。 FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。 YGC发生场景：edn空间不足 FGC发生场景：old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live) 49，一个线程池正在处理服务如果忽然断电该怎么办？ 答： 队列实现持久化储存，下次启动自动载入。 但是实际需要看情况，大体思路是这样。 添加标志位，未处理 0，处理中 1，已处理 2。每次启动的时候，把所有状态为 1 的，置为 0。或者定时器处理 关键性的应用就给电脑配个 UPS。 50，SpringBoot的优点？ 答： 快速构建项目，极大的提高了开发、部署效率。 对主流开发框架的无配置集成。 项目可独立运行，无须外部依赖Servlet容器。 提供运行时的应用监控。 51，DoS，DDoS，DRDoS攻击分别是什么？ 答：DoS是Denial of Service的简写就是拒绝服务。 DDoS就是Distributed Denial of Service的简写就是分布式拒绝服务。 DRDoS就是Distributed Reflection Denial of Service的简写,分布反射式拒绝服务。 DoS、DDos以及DRDoS攻击手段和防范措施 52，服务限流的方式？ 答： 漏桶：水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求。 令牌桶算法：系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token，如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token就拒绝服务。 基于redis实现的限流：假设每分钟访问次数不能超过10次，在Redis中创建一个键，过期60秒，对此服务接口的访问就把键值加1，在60秒内增加到10的时候，禁止访问服务接口。 计数器，滑动窗口 53，Quartz实现原理? 答：A、scheduler是一个计划调度器容器（总部），容器里面可以盛放众多的JobDetail和trigger，当容器启动后，里面的每个JobDetail都会根据trigger按部就班自动去执行。 B、JobDetail是一个可执行的工作，它本身可能是有状态的。 C、Trigger代表一个调度参数的配置，什么时候去调。 D、当JobDetail和Trigger在scheduler容器上注册后，形成了装配好的作业（JobDetail和Trigger所组成的一对儿），就可以伴随容器启动而调度执行了。 E、scheduler是个容器，容器中有一个线程池，用来并行调度执行每个作业，这样可以提高容器效率。 54，数据库的锁？ 答：行锁（共享锁和排他锁），表锁，页级锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁等 55，简述ThreadPoolExecutor内部工作原理？ 答： 先查看当前运行状态，如果不是RUNNING 状态会拒绝执行任务，如果是RUNNING状态，就会查看当前运行的线程数量，如果小于核心线程数，会创建新的线程来执行这个任务，如果不小于核心线程，会将这个任务放到阻塞队列去等代执行，直到上一个任务执行完再来执行这个任务。如果失败会创建一个非核心线程来执行这个任务如果当前线程数大于最大线程数，会直接拒绝该任务。 56，聚集索引和非聚集索引的区别？ 答： 聚集索引： 索引中键值的逻辑顺序决定了表中相应行的物理顺序（索引中的数据物理存放地址和索引的顺序是一致的），可以这么理解：只要是索引是连续的，那么数据在存储介质上的存储位置也是连续的。 比方说：想要到字典上查找一个字，我们可以根据字典前面的拼音找到该字，注意拼音的排列时有顺序的。 聚集索引就像我们根据拼音的顺序查字典一样，可以大大的提高效率。在经常搜索一定范围的值时，通过索引找到第一条数据，根据物理地址连续存储的特点，然后检索相邻的数据，直到到达条件截至项。 非聚集索引 索引的逻辑顺序与磁盘上的物理存储顺序不同。非聚集索引的键值在逻辑上也是连续的，但是表中的数据在存储介质上的物理顺序是不一致的，即记录的逻辑顺序和实际存储的物理顺序没有任何联系。索引的记录节点有一个数据指针指向真正的数据存储位置。 总结如下： 如果一个主键被定义了，那么这个主键就是作为聚集索引 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。 InnoDB引擎会为每张表都加一个聚集索引，而聚集索引指向的的数据又是以物理磁盘顺序来存储的，自增的主键会把数据自动向后插入，避免了插入过程中的聚集索引排序问题。如果对聚集索引进行排序，这会带来磁盘IO性能损耗是非常大的。 57，java并发包下有哪些类？ 答：ConcurrentHashMap，ConcurrentSkipListMap，ConcurrentNavigableMap CopyOnWriteArrayList BlockingQueue，BlockingDeque （ArrayBlockingQueue，LinkedBlockingDeque，LinkedBlockingQueue，DelayQueue，PriorityBlockingQueue，SynchronousQueue） ConcurrentLinkedDeque，ConcurrentLinkedQueue，TransferQueue，LinkedTransferQueue CopyOnWriteArraySet，ConcurrentSkipListSet CyclicBarrier，CountDownLatch Lock（ReetrantLock，ReetrantReadWriteLock） Atomic包 58，threadlocal为什么会出现oom？ 答：ThreadLocal里面使用了一个存在弱引用的map, map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例。这个Map的确使用了弱引用，不过弱引用只是针对key。每个key都弱引用指向threadlocal。 当把threadlocal实例置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被gc回收。 但是，我们的value却不能回收，而这块value永远不会被访问到了，所以存在着内存泄露。因为存在一条从current thread连接过来的强引用。只有当前thread结束以后，current thread就不会存在栈中，强引用断开，Current Thread、Map value将全部被GC回收。最好的做法是将调用threadlocal的remove方法。 在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value，但是这些被动的预防措施并不能保证不会内存泄漏： （1）使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致内存泄漏。 （2）分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏，因为这块内存一直存在。 59，mysql数据库锁表怎么解决？ 答：查询锁表信息 当前运行的所有事务 select * from information_schema.innodb_trx 当前出现的锁 select * from information_schema.innodb_locks 锁等待的对应关系 select * from information_schema.innodb_lock_waits 通过 select * from information_schema.innodb_trx 查询 trx_mysql_thread_id然后执行 kill 线程ID KILL 8807;//后面的数字即时进程的ID 60，java 判断对象是否是某个类的类型方法？ instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。 getClass判断，如o.getClass().equals(ClassA.class)。（使用instanceof来判断一个对象是不是属于某个类，但是有时候这个类是继承于一个父类的，所以，不能严格判断出是不是自己的类，而不是自己的父类。） 61，Spring+MyBatis实现读写分离简述？ 答： 方案一：通过MyBatis配置文件创建读写分离两个DataSource，每个SqlSessionFactoryBean对象的mapperLocations属性制定两个读写数据源的配置文件。将所有读的操作配置在读文件中，所有写的操作配置在写文件中。 方案二：通过Spring AOP在业务层实现读写分离，在DAO层调用前定义切面，利用Spring的AbstractRoutingDataSource解决多数据源的问题，实现动态选择数据源 方案三：通过Mybatis的Plugin在业务层实现数据库读写分离，在MyBatis创建Statement对象前通过拦截器选择真正的数据源，在拦截器中根据方法名称不同（select、update、insert、delete）选择数据源。 方案四：通过spring的AbstractRoutingDataSource和mybatis Plugin拦截器实现非常友好的读写分离，原有代码不需要任何改变。推荐第四种方案 62，红黑树的特点？ 答：（1）每个节点或者是黑色，或者是红色。 （2）根节点是黑色。 （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] （4）如果一个节点是红色的，则它的子节点必须是黑色的。 （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。[这里指到叶子节点的路径] 63，kafka消息会不会丢失？ 答：Kafka消息发送分同步(sync)、异步(async)两种方式。默认是使用同步方式，可通过producer.type属性进行配置；Kafka保证消息被安全生产，有三个选项分别是0,1,-1。 通过request.required.acks属性进行配置： 0代表：不进行消息接收是否成功的确认(默认值)； 1代表：当Leader副本接收成功后，返回接收成功确认信息； -1代表：当Leader和Follower副本都接收成功后，返回接收成功确认信息； 网络异常 acks设置为0时，不和Kafka集群进行消息接受确认，当网络发生异常等情况时，存在消息丢失的可能； 客户端异常 异步发送时，消息并没有直接发送至Kafka集群，而是在Client端按一定规则缓存并批量发送。在这期间，如果客户端发生死机等情况，都会导致消息的丢失； 缓冲区满了 异步发送时，Client端缓存的消息超出了缓冲池的大小，也存在消息丢失的可能； Leader副本异常 acks设置为1时，Leader副本接收成功，Kafka集群就返回成功确认信息，而Follower副本可能还在同步。这时Leader副本突然出现异常，新Leader副本(原Follower副本)未能和其保持一致，就会出现消息丢失的情况； 以上就是消息丢失的几种情况，在日常应用中，我们需要结合自身的应用场景来选择不同的配置。 想要更高的吞吐量就设置：异步、ack=0；想要不丢失消息数据就选：同步、ack=-1策略 64，kafka的leader副本选举？ 答：如果某个分区patition的Leader挂了,那么其它跟随者将会进行选举产生一个新的leader,之后所有的读写就会转移到这个新的Leader上,在kafka中,其不是采用常见的多数选举的方式进行副本的Leader选举,而是会在Zookeeper上针对每个Topic维护一个称为ISR（in-sync replica，已同步的副本）的集合,显然还有一些副本没有来得及同步。只有这个ISR列表里面的才有资格成为leader(先使用ISR里面的第一个，如果不行依次类推，因为ISR里面的是同步副本，消息是最完整且各个节点都是一样的)。 通过ISR,kafka需要的冗余度较低，可以容忍的失败数比较高。假设某个topic有f+1个副本，kafka可以容忍f个不可用,当然,如果全部ISR里面的副本都不可用,也可以选择其他可用的副本,只是存在数据的不一致。 65，kafka消息的检索？ 答：其实很简单主要是用二分查找算法,比如我们要查找一条offest=10000的文件,kafka首先会在对应分区下的log文件里采用二分查看定位到某个记录该offest =10000这条消息的log,然后从相应的index文件定位其偏移量,然后拿着偏移量到log里面直接获取。这样就完成了一个消息的检索过程。 66，RabbitMQ 集群方式？ 答： 1）普通集群： 以两个节点（rabbit01、rabbit02）为例来进行说明。 rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构，但消息实体只存在于其中一个节点rabbit01（或者rabbit02）中。 当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。 2）镜像集群： 在普通集群的基础上，把需要的队列做成镜像队列，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取，也就是说多少节点消息就会备份多少份。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用 由于镜像队列之间消息自动同步，且内部有选举master机制，即使master节点宕机也不会影响整个集群的使用，达到去中心化的目的，从而有效的防止消息丢失及服务不可用等问题 67，ElasticSearch如何解决深度分页的问题？ 答：使用scroll（有状态）和search after（无状态）的游标方式。 68，java代码优化(一) 答：尽量指定类、方法的final修饰符。 尽量重用对象。 尽可能使用局部变量。 及时关闭流。 尽量减少对变量的重复计算。 尽量采用懒加载的策略，即在需要的时候才创建。 慎用异常。 不要在循环中使用try…catch…，应该把其放在最外层。 如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度。 当复制大量数据时，使用System.arraycopy()命令。 乘法和除法使用移位操作。 循环内不要不断创建对象引用。 基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList。 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销。 不要将数组声明为public static final。 69，java代码优化(二) 答：尽量在合适的场合使用单例。 尽量避免随意使用静态变量。 及时清除不再需要的会话。 实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历 使用同步代码块替代同步方法。 将常量声明为static final，并以大写命名。 不要创建一些不使用的对象，不要导入一些不使用的类。 程序运行过程中避免使用反射。 使用数据库连接池和线程池。 使用带缓冲的输入输出流进行IO操作。 顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList。 不要让public方法中有太多的形参。 字符串变量和字符串常量equals的时候将字符串常量写在前面。 请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者。 不要对数组使用toString()方法。 不要对超出范围的基本数据类型做向下强制转型。 70，java代码优化(三) 答:公用的集合类中不使用的数据一定要及时remove掉。 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+&quot;“最慢 使用最有效率的方式去遍历Map。 对资源的close()建议分开操作。 对于ThreadLocal使用前或者使用后一定要先remove。 切记以常量定义的方式替代魔鬼数字，魔鬼数字的存在将极大地降低代码可读性，字符串常量是否使用常量定义可以视情况而定。 long或者Long初始赋值时，使用大写的L而不是小写的l，因为字母l极易与数字1混淆，这个点非常细节，值得注意。 所有重写的方法必须保留@Override注解。 推荐使用JDK7中新引入的Objects工具类来进行对象的equals比较，直接a.equals(b)，有空指针异常的风险。 循环体内不要使用”+&quot;进行字符串拼接，而直接使用StringBuilder不断append。 不捕获Java类库中定义的继承自RuntimeException的运行时异常类。 避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed导致的性能下降，JDK7之后，可以使用ThreadLocalRandom来获取随机数。 静态类、单例类、工厂类将它们的构造函数置为private。 71，单点登录原理与简单实现？ 答：相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明 单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明 72，MQ做数据同步也会造成不一致，又需要引入监控，实时计算2个集群的数据同步，做一致性同步。大部分来说，同步es和solr不要在代码中去同步，同步失败无法保证事务，而且业务耦合。可以使用Databug和cancel等工具去做代码解耦，MQ支持重试，存储失败后抛出异常下次再处理。数据做异构，对外服务时任意拼装，MYSQL在半同步复制上做了一些优化，保证了一致性，引入了诸如paxos等主流算法保证强一致性问题。 当DB（监听从库），binlog有变化，cancel监听到时候解析过滤发送MQ（表名字，主键等）到变化的实时从库中查询数据同步到ES聚合表，MQ可以重试，系统解耦。事务log挖掘县城会对DB的事务log监听，并把这些事件发布到消息代理。 73，分布式服务调用可以实现跟踪系统，可以在业务日志中添加调用链ID，各个环节RPC均添加调用时延,QPS等。 非业务组件应该少加入业务代码，服务调用采用买点，也会采用配置采样率方式，买点即当前节点的上下文信息，包含TraceId，RPCId，开始结束时间，类型，协议，调用方IP，端口，服务名等，以及其他异常信息，报文等扩展，日志采用离线+实时的如flume结合kafka等，应按照TraceId汇总日志后按RPCId顺序整理。 74，Sentinel 工作原理？ 答：（1）每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令； （2）如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线； （3）如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态； （4）当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态，则 Master 会被标记为客观下线； （5）在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令； 当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次； （6）若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除； （7）若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。 监控（ Monitoring ）： Redis Sentinel 实时监控主服务器和从服务器运行状态； 自动故障转移：如果一个 master 不正常运行了，哨兵可以启动一个故障转移进程，将一个 slave 升级成为 master，其他的 slave 被重新配置使用新的 master，并且应用程序使用 Redis 服务端通知的新地址； 75，高性能统计UV的方式？ （1）使用redis的set集合 （2）使用redis的bitmap（注意内存消耗） 76，Hbase二级索引，索引海量数据实现方案？ 答： (1) 方案1:使用开源的hbase-indexer，是借助于hbase的WAL实现，不会影响hbase性能 https://blog.csdn.net/xiahoujie_90/article/details/53400044 (2) 方案2：基于ES自己实现，利用habse的协处理器实现，会影响hbase性能 关键注意点：因为数据是存在Hbase中，ES充当的是索引角色，所以在创建ES的mapping时， 应指定_source为enabled:false。关闭存储原始文档。 https://wenku.baidu.com/view/422722fdd0f34693daef5ef7ba0d4a7303766c71.html 77，Elasticsearch分片使用优化? 答：(1)拆分集群 对于存在明显分界线的业务，可以按照业务、地域使用不同集群，这种拆分集群的思路是非常靠谱的。对于我们的场景，已经按照地域拆分了集群，且同一地域的子业务间分界线不明显，拆分过多的集群维护成本较高。 (2)调整滚动周期 根据保留时长调整index滚动周期是最简单有效的思路。例如保留3天的数据按天滚动，保留31天的数据按周滚动，保留一年的数据按月滚动。合理的滚动周期，可以在存储成本增加不大的情况下，大幅降低分片数量。 对于我们的场景，大部分数据保留31天，在按周滚动的情况下，集群的总分片数可以下降到6.5w~个。 (3)合理设置分片数和副本数 除个别子业务压力较高外，大部分业务压力较小，合理设置单Index的分片数效果也不错。我们的经验是单个分片的大小在10GB~30GB之间比较合适，对于压力非常小的业务可以直接分配1个分片。其他用户可结合具体场景考虑，同时注意单分片的记录条数不要超过上限2,147,483,519。 在平衡我们的业务场景对数据可靠性的要求 及 不同副本数对存储成本的开销 两个因素之后，我们选择使用一主一从的副本策略。 目前我们集群单Index的平均分配数为3，集群的总分片数下降到3w~个。 (4)分片分配流程优化 默认情况下，ES在分配分片时会考虑分片relocation对磁盘空间的影响。在分片数较少时，这个优化处理的副作用不明显。但随着单机分片数量的上升，这个优化处理涉及的多层循环嵌套过程耗时愈发明显。可通过cluster.routing.allocation.disk.include_relocations: false关闭此功能，这对磁盘均衡程度影响不明显。 (5)预创建Index 对于单集群3w分片的场景，集中在每周某天0点创建Index，对集群的压力还是较大，且存储空间存在波动。考虑到集群的持续扩展能力和可靠性，我们采用预创建方式提前创建分片，并把按Index的创建时间均匀打散到每周的每一天。 (6)持续调整分片数 对于集群分片的调整，通常不是一蹴而就的。随着业务的发展，不断新增的子业务 或 原有子业务规模发生突变，都需要持续调整分片数量。 默认情况下，新增的子业务会有默认的分片数量，如果不足，会在测试阶段及上线初期及时发现。随着业务发展，系统会考虑Index近期的数据量、写入速度、集群规模等因素，动态调整分片数量。 78，如何编写高质量代码151建议？ 答： 一、Java开发中通用的方法和准则 不要在常量和变量中出现易混淆的字母; 莫让常量蜕变成变量; 三元操作符的类型务必一致; 避免带有变长参数的方法重载; 别让null值和空值威胁到变长方法; 覆写变长方法也要循规蹈矩; 警惕字增的陷阱; 不要让旧语法困扰你; 少用静态导入; 不要在本类中覆盖静态导入的变量和方法; 养成良好习惯，显示声明UID; 避免用序列化类在构造函数中为不变量赋值; 避免为final变量复杂赋值; 使用序列化类的私有方法巧妙解决部分属性持久化问题; break万万不可忘; 易变业务使用脚本语言编写; 慎用动态编译; 避免instantceof非预期结果; 断言对决不是鸡肋; 不要只替换一个类; 二、基本类型 使用偶判断，不用奇判断; 用整数类型处理货币; 不要让类型默默转换; 边界，边界，还是边界; 不要让四舍五入亏了一方; 提防包装类型的null值; 谨慎包装类型的大小比较; 优先使用整型池; 优先选择基本类型; 不要随便设置随机种子; 三、类、对象及方法 在接口中不要存在实现代码; 静态变量一定要先声明后赋值; 不要覆写静态方法; 构造函数尽量简化; 避免在构造函数中初始化其他类; 使用构造代码块精炼程序; 使用静态内部类提供封装性; 使用匿名类的构造函数; 匿名类的构造函数很特殊; 让多重继承成为现实; 让工具类不可实例化; 避免对象的浅拷贝; 推荐使用序列化实现对象的拷贝; 覆写equals方法时不要识别不出自己; equals应该考虑null值情景; 在equals中使用getClass进行类型判断; 覆写equals方法必须覆写hashCode方法; 推荐覆写toString方法; 使用package-info类为包服务; 不要主动进行垃圾回收; 四、字符串 推荐使用String直接量赋值; 注意方法中传递的参数要求; 正确使用String、StringBuffer、StringBuilder; 注意字符串的位置; 自由选择字符串拼接方法; 推荐在复杂字符串操作中使用正则表达式; 强烈建议使用UTF编码; 对字符串排序持一种宽容的心态; 五、数组和集合 性能考虑，数组是首选; 若有必要，使用变长数组; 警惕数组的浅拷贝; 在明确的场景下，为集合指定初始容量; 多种最值方法，适时选择; 避开基本类型数组转换列表陷阱; asList方法产生的List对象不可更改; 不同的列表选择不同的遍历方法; 频繁插入和删除时使用LinkedList; 列表相等只需关心元素数据; 推荐使用subList处理局部列表; 生成子表后不要再操作原列表; 使用Comparator进行排序; 不推荐使用binarySearch对列表进行检索; 集合中的元素必须做到compareTo和equals同步; 集合运算时使用更优雅的方式; 使用shuffle大乱列表; 减少HashMap中元素的数量; 集合中的哈希码不要重复; 多线程使用Vector或者HashTable; 非稳定排序推荐使用List; 六、枚举和注解 推荐使用枚举定义常量; 使用构造函数协助描述枚举项; 小心switch带来的空值异常; 在switch的default代码块中增加AssertionError错误; 使用valueOf前必须进行校验; 用枚举实现工厂方法模式更简洁; 枚举项的数量限制在64个以内; 小心注解继承; 枚举和注解结合使用威力更大; 注意@Override不同版本的区别; 七、枚举和注解 Java的泛型是类型擦除的; 不能初始化泛型参数和数组; 强制声明泛型的实际类型; 不同的场景使用不同的泛型通配符; 警惕泛型是不能协变和逆变的; 建议采用的顺序是List、List&lt;?&gt;、List; 严格限定泛型类型采用多重界限; 数组的真实类型必须是泛型类型的子类型; 注意Class类的特殊性; 适时选择getDeclaredXXX和getXXX; 反射访问属性或方法时将Accessible设置为true; 使用forName动态加载类文件; 动态加载不合适数组; 动态代理可以使代理模式更加灵活; 反射让模板方法模式更强大; 不需要太多关注反射效率; 八、异常 提倡异常封装; 采用异常链传递异常; 受检异常尽可能转化为非受检异常; 不要在finally块中处理返回值; 使用Throwable获取栈信息; 异常只为异常服务; 多使用异常，把性能问题放一边; 九、多线程和并发 不推荐覆写start方法; 启动线程前stop方法是不可靠的; 不使用stop方法停止线程; 线程优先级只使用三个等级; 使用线程异常处理器提升系统可靠性; volatile不能保证数据同步; 异步运算多考虑使用Callable接口; 优先选择线程池; 适时选择不同的线程池来实现; Lock与synchronized是不一样的; 预防线程死锁; 适当设置阻塞队列长度; 使用CountDownLatch协调子线程; CyclicBarrier让多线程齐步走;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19年面试]]></title>
    <url>%2F2019%2F08%2F20%2F%E9%9D%A2%E8%AF%95%2F19%E5%B9%B4%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[答应别人的东西， 一定要准时反馈； 1. 自我介绍， 总共做过几年java , 公司介绍， 最近两年项目介绍，使用或接触过的技术介绍， 目前在职主要做哪些方面的工作； 2. 项目中数据库层面如何设计的？ 3. 项目中涉及多线程如何处理的？ 4. app做的是用html5 + 一些vue , mui, 阿拉丁的一些js 融合的框架， 做的嵌套开发，不是原生页面， 做的是插件， 是放在别人的app平台进行部署。 5. 数据锁方面有涉及么？ 共享锁下其它用户可以并发读取，查询数据。但不能增删改数据和资源共享，加了共享锁可以继续加共享锁，不能加排他锁； 排他锁下不能加其他锁，排他锁内可以读写， 其他用户只能等当前用户锁释放掉后，才能读写； 共享锁只用于表级， 使用lock命令 ，排他锁用于行级 ，使用for update； 解锁需要dba的权限，找到当前锁的sid, 然后kill掉即可。 6. 后台框架用的什么？ Spring+springmvc+mybatis 框架 ， Dubbo， zookeeper, maven, log4j, redis , 常用的一些设计模式思想要记， socket , rocketmq , quartz , ESB, webservice 7. springmvc这块熟悉么？ 8. spring的哪些地方用到了哪些设计模式， 你能说出来一些么？ 简单工厂(例如在配置文件中定义一个bean), 单例模式（可以在xml中指定使用单例还是每次new新的实例）， 适配器， 观察者模式（监听器的实现）， 策略模式（定义不同算法，根据不同客户需求调用不同方法）， 模板方法（jdbc连接池这块，将变化的东西集中写在一个地方，然后通过传入回调给模板对象，即完成调用）， 9. aop， ioc 分别代表什么意思？ AOP切面编程， 实现原理是基于动态代理实现的。动态代理相当于中转，所有客户端的请求，我可以集中到一份方法进行处理，可以根据我自己的处理逻辑控制是否进行转接， 也相当于增强，在实际调用的过程中，顺带执行点其他任务 ；使用场景：安全校验，事务，权限管理，日志等。 Ioc 控制反转，xml中bean的注入， 我们需要的对象不需要自己手动去new了，全都交给spring容器进行管理，用到什么直接从spring中取就行了。 10. aop 用到了什么设计模式呢？ 动态代理模式 11. ioc用到了什么设计模式呢？ 依赖注入模式 单例模式 代理模式 工厂模式 模板方法模式 12. 代理模式了解过么？ aop有没有用到代理模式呢？ 了解过， 为某个对象提供一个代理，来控制对这个对象的直接访问， aop使用的是jdk的动态代理， 提供前置增强，后置增强或过程中增强； 13. spring 通常有一些配置， 都有哪些？ Bean的定义， 静态文件过滤， 上传下载文件配置，数据库连接池配置，事务配置，持久层配置，外包文件引入， 常用注解, 缓存配置：@AspectJ（注解切面， @EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持）， xml中可配置bean是否单例模式使用，自定义监听器， 自定义拦截器， @Import（导入配置项）， @Scheduled（配置定时任务），事务注解@Transactional 14. 事务配置用的多么？ 用过， xml中引入tx标签，定义事务； 项目service层使用@Transactional注解，实现事务操作，可声明只读或写； 使用拦截器配置事务；xml中定义bean, 装配spring的事务类，通过属性赋值，实现事务配置； 15. spring中有两大块， aop, ioc ， 主要用到的技术层面有哪些？ 单例模式，代理模式，模板方法，工厂模式等 16. 反射你是怎么理解的？ 反射，jvm在类的编译加载过程中，将对应的类，属性登记在册，然后反射通过在类加载运行过程中，通过对应的类的名称或者他的一个实例对象，去找对应这个类的所有方法和属性，如果明确知道哪个方法，还可以通过传参来执行这个方法。 17. aop的应用场景有哪些？ 事务，安全验证，日志， 权限管理， 拦截过滤等。 18. aop常用的注解有哪些？ @Aspect（配置切面） @Before（前置增强，都会执行） @After（后置增强，都会执行） @AfterReturning（后置增强，目标方法执行成功后才会执行） @AfterThrowing（后置增强， 抛出异常后会执行） @Around（环绕增强， 相当于前置增强和后置目标方法执行成功后会执行） @annotation(可以指定切面执行时，只要有请求就可以执行，不用指定具体的代码层级) 19. oracle常用的一些函数有哪些？ Concat: 字符串拼接， 或者 || Instr: 指定字符串位置 Length: 长度 Trim: 去空格 Lower: 小写 Upper:大写 Nvl: 判断空 Replace: 替换 Substr: 截取 Floor: 向下取整 To_number: To_char: To_date: Decode: 判断函数等等 20. sql调优的话，你了解有哪些？ 创建索引 避免在索引上使用计算 使用预编译查询（使用参数化sql, 因为数据库可以预编译，下次执行速度更快） 调整Where字句中的连接顺序 尽量将多条SQL语句压缩到一句SQL中 用where字句替换HAVING字句 使用表的别名（并把别名放在列名上） 用union all替换union 考虑使用“临时表”暂存中间结果（这样每次查询就避免扫描主表） 查询select语句优化（不要使用select * ） 20. 索引创建原则？ 哪些情况不会走索引？ 对于查询频率高的字段创建索引 索引的数目不宜太多 选择唯一性索引 尽量使用列数据量少的索引 尽量使用前缀来索引 删除不再使用或者很少使用的索引 select *，可能会导致不走索引 索引列上存在null值，可能不能走索引 索引列上有函数运算，导致不走索引 隐式类型转换导致不走索引 ！=或者&lt;&gt;(不等于），可能导致不走索引 使用like, in 等， 可能导致不走索引 21. 乐观锁和悲观锁介绍？区别主要是什么？ 乐观锁适用于写比较少的情况下（多读场景）； 一般多写的场景下用悲观锁就比较合适（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程） 22. 常用的集合类有哪些？ 如何我想插入数据块的话，用哪个list？ 大类有iterator, collection , map ,array Iterator包括： ListIterator, Collection包括： list, set, linkedlist, arraylist,hashset, linkedhashset, treeset（使用二叉树排序）, sortedset Map包括： hashmap, ConcurrentHashMap , treemap , sortedmap 自定义集合内部排序，需要实现comparable 接口 23. hashmap的原理？ 存储原理和排序原理？ jdk8 和 7对于hashmap有哪些区别？ 存储方式是以键值对存储的，怎么根据key找到对应的值的？ map中有两个hash值是一样的， 怎么找到对应的value 或者key ? 存储的方式是键值对，底层是数组和链表的形式存在，实现类是Entry 总结：HashMap的实现原理： 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。 Jdk7，8的区别： jdk8添加了红黑树，在元素个数超过8个才会使用， jdk7中有一个内部类Entry, jdk8使用的是Node类， 使用hashmap要注意如果key存储的是对象,则一定要重新hashcode和equal方法 Map先根据key的hash值到table数组中找对应的下标，获取对应的entry, 如果一个位置存在多个entry，那么hash值肯定也是相等的，遍历所有entry， 去比较entry的key值，如果与传递过来的key值相等，则返回entry对应的value值， 最后都没有找到则返回null 24. 创建线程有几种方式？ 线程启动用的哪个方法？ 为什么不用run 而用start? 创建线程有4种方式： 实现runnable接口， 继承thread类， 使用线程池Executor，实现callable通过创建FutureTask类对象，这个可以自定义返回类型。 Run方法是普通的方法，有方法体，如果使用run方法，程序需要一步一步走完，才能执行下一个方法，就达不到多线程的目的，使用start方法，将线程放在等待开始调用队列中，等待cpu去调度，jvm去运行。 25. liunx常用操作命令介绍？ Less, cat, ll , la, grep , tail , curl, vi, top, telnet , rm –rf , scop , mkdir , mv , pwd , 26. 工作这几年，有没有让你印象比较深刻的事情，或者让你比较自豪的事情？ 印象深刻：有一天凌晨4点，是我做的一个年检项目关联系统上线，需要做止付和解止付接口验证操作，需要生产上通过调用我的接口验证他们的功能上线是否成功， 把我留在公司一整宿，验证完没有问题，系统验证搞得我很紧张，还担心自己的功能出问题，结果一夜很精神，就直接在公司打代码到早上上班，这是我第一次通宵在公司打代码到第二天早上上班。 比较自豪：18年初，后端架构升级到微服务开发部署，前端架构改造使用新的框架vue, 后端是我自己看着api文档一步步搭建起来的，各个组件拆分部署也是自己弄的， 另外新架构那时候刚开始引入git, vue， 10几个java开发，还都是我最先用起来，并且抽空给他们开会做过几次技术培训。而且现在我在项目中不管是开发问题查找，业务需求还是环境，部署问题，基本上每天都有2，3个人来找我咨询。 27. 有没有做过性能调优方面的东西？ Sql优化，jvm参数调优，java代码性能调优 做过： 1.不要直接将项目整体做优化，要有确切的定位哪些确实需要优化，哪些不需要优化； 2.检查需要优化的代码部分，使用分析器来定位性能瓶颈在哪些地方； 3.经常定义一些日志在关键的地方，用来定位分析性能卡顿的代码，并且分析性能瓶颈； 4.尽量使用基本类型来代替使用包装类型； 5.避免使用bigInteger, bigDecimal 因为占用内存太高； 6.使用日志前，判断当前日志级别是否能被显示； 7.尽可能使用缓存来来避免执行耗时或频繁使用的代码片段； 8.慎用线程同步的方法； 9.尽量使用局部变量，因为局部变量保存在栈中，方法结束就会被gc清理，速度也快， 而类变量保存在堆中，耗费内存，访问也慢； 10.创建集合尽量指定一个初始大小； 11.尽量在适合的场合使用单例，例如数据共享，资源并发访问等； 28. 有没有做过压测？ 压测tps比较低的话，通常有哪些方法可以去调？有没有通过工具去查找分析他性能瓶颈的地方？ 有做过； tps比较低的话， 找几个地方进行分析：1. 网络带宽限制；2.连接池大小资源限制（例如tomcat与数据库连接池大小限制，超过则等待）；3. 数据库sql性能影响；4.硬件资源限制（内存，cpu等）；5. 业务逻辑较为复杂；6. 缓存策略或配置等；7. Java编码方式问题； 使用过jmeter开多并发来测试过； 29. 你了解架构方面么？ 了解； 架构搭建部署有几个点需要注意： 整体敏捷度，组件拆分合理性；部署方面，模块之间耦合度； 单元测试是否方便；性能方面；开发便捷性和代码重用性； 30. 比如行内新出一个需求，要做设计，出方案，这块有没有做过？ 做过，最近刚做了一个小鹰助手的需求设计方案； 31. 懂技术架构，懂性能调优？ 32. 设计模式的思想介绍： 开闭原则：开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码。 针对接口编程，真对接口编程，依赖于抽象而不依赖于具体。 尽量使用合成/聚合的方式，而不是使用继承。 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 使用多个隔离的接口，比使用单个接口要好。 里氏代换原则：（1）子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。（2）返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。（3）还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。 而不能声明抛出父类没有声明的异常 33. 同步锁的几种方式？ synchronized 1.使用synchronized修饰方法实现同步机制； 2.使用volatile修饰变量实现线程同步； 3.使用阻塞队列实现线程同步； 34. es简单介绍？ 35. redis简单介绍？ 36. springboot 面试题相关？ 37. logback相关？ 38. hbase简单介绍？ 39. 高并发的情况，说出你的解决方案？ 40. jvm内部的一些原理？ 堆和栈的区别？ 41. 二分算法介绍？ 红黑树？ 二叉树？ 冒泡排序？ 42. hashcode, equal 的重写? 重写equals ,也要重写hashcode, Equals相等，则hashcode也相等； 43.cglib 动态代理介绍？为什么比jdk动态代理高效？ jdk通过发射的方式来调用 cglib 通过继承类的方式来调用，为代理类和被代理类各生成一个class,并且分配一个index方法，通过index方法直接定位要执行的方法进行调用，不用反射调用，所以效率比较高一点。 44. 面试的时候讲的高端一些？ 45. 平常开发测试人少访问量，性能看不出来，但是一到生产，就会很慢，很卡，生产上如何进行分析，性能出现在哪地方的问题？ 分析工具常用 的有哪些？ 1. 生产上的话， 通过观察日志， 2. 使用性能分析工具， 与eclipse集成的几款工具，profile, jConsole, 使用cat监控工具 46. sql性能如何分析？ 通过任务计划观察索引执行情况 47. 高并发解决方案或者分析方案？ Jmeter, loadrunner 做性能测试， 各有什么特点，如何进行分析？ 使用乐观锁，队列 ， 和增加版本号来控制高并发提交数据 48. 自己有没有做过压测，如何做的？ 1. 使用jmeter工具，模拟高并发请求，观察tps 2. 或者自己使用多线程模拟高并发来观察接口压力情况 49. spring和springmvc 有什么区别？ spring提供了一整套流程处理，包括业务层，数据层,事务支持等，并且提供了两大核心功能aop（面向切面，可以用来解决一些公共问题）和ioc（bean的创建和注入简化并便于维护）, Springmvc主要作为控制层来实现，从请求到controller，业务处理完成后，返回视图和数据给客户端。 2）springmvc的流程： 1、 用户发送请求至前端控制器DispatcherServlet； 2、DispatcherServlet收到请求调用HandlerMapping处理器映射器； 3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet； 4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器，执行处理器(Controller，也叫后端控制器)； 5、Controller执行完成返回ModelAndView，并返回给HandlerAdapter，HandlerAdapter将结果返回给DispatcherServlet； 6、DispatcherServlet将ModelAndView传给ViewReslover视图解析器，ViewReslover解析后返回具体View给DispatcherServlet； 7、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）后返回给给客户 50. 什么是分布式架构？有没有做过分布式系统？ 分布式系统中如何实现数据共享和服务器中间通信？ 链表结构有没有了解过？ 1. 将相同的应用组件部署多份， 2. 业务拆分多个模块，分别部署 链表结构，可比喻为火车，每个链表都是一节车厢，数据存储在车厢中， 而每个火车节都有一个指针，连接着下一个火车节。 51. 服务端，系统之间调用的话，如果访问量很大或者调用很频繁的话， 系统资源就会消耗很大？ 服务端通信有几种方式： socket方式通信，短连接（通信完立马断掉），长连接（同步和异步方式） mq方式同步或者通信 Webervice方式 Redis发布订阅 52. rocketMq 架构介绍？ 如何保证mq数据不丢失和数据重复问题？ Name Server 为 producer 和 consumer 提供路由信息; Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备; 生产者（Producer）; 消费者（Consumer）; 2). 首先从生产者方面考虑，每条消息发送成功与否都会有一个状态对应，如果失败状态，则重发一遍即可。并且还可以日志来查询是否发送并成功存储进boker块当中； 3)从broker块分析，消息支持持久化到日志里面，即使宕机重启，未读消息还是可以加载出来，而且broker支持主从同步，使得消息也不会丢失； 4)从消费者角度考虑，消费者自身维护一个持久化的offset,标记已经成功消费或者消费失败时，发给broker的消息下标，如果消费失败，并且borker挂掉了，那么消费者会定时重试发送动作，如果消费者和broker一起挂了， 那么重启后，会继续从拉去offset之前的消息到本地。 a) mq有发送日志记录，每条发送消息都有对应的消息id, 他发送给消费者时会自动判断并去重， 还有就是可以自己在业务端处理重复问题。 53. redis常见面试题？ Redis持久化？ 持久化，就是把数据写到内存中; Redis支持数据类型： list , hash , set , zset , String ; Redis有一种通讯协议RESP，可以实现客户端于服务端通信， 类型websocket ; Redis有几种架构部署模式： 单机模式： 搭建简单，内存容量有限，无法扩容 集群模式：节点之间通过数据共享， 哨兵模式：通过间隔时间监听master节点，出现master节点不可用时，会通过投票选举新的master, 节点直接数据也是通过master同步到各个节点，master写压力比较大 主从复制：有一个master主节点，多个slave从节点，数据更新的话， master都会同步到slave从节点，用来保证数据一致，无法保证高可用，master写压力比较大 54. 组合索引， 只有一列条件，会不会走索引？ 如果这一列是组合索引的第一个字段的话， 会走索引，不是则不走 55.hashmap 和 concurrentmap 有什么区别？ 一个是线程安全，一个不是线程安全的， 因为concurrentmap使用了分段锁，将map数据分成一段一段存储，然后给每一段数据加上一把锁，就实现了高并发。 56. map底层的链表是用来做什么的？ 链表存储的是Entry泛型接口， 包含key, value 以及next(指向下一个entry对象元素) 57. 乐观锁，悲观锁有什么区别？ 乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检查，（通过对比版本号，查询的时候会带一个数据库版本号，更新的时候用来做对比） 悲观锁， 每次它去拿数据的时候都会上锁，知道锁释放，别人才能操作，不适用于高并发 58. 重写equal时， 一定要重写hashcode, 因为比较相等时基于hashcode实现的， 59. final修饰对象， 修饰方法，修饰类，变量？ final修饰类是不能被继承； final修饰对象不能在被创建； fianl修饰方法不能在子类中被覆盖； final修饰变量，称为常量，初始化以后不能改变值。 60.equal如何比较两个对象相等的？ == 又是如何比较的？ equals 通常用来比较两个对象的内容是否相等， ‘’ 通常用来比较两个对象的地址是否相等 equals默认等同于‘’ 如果判断一个类或对象是否相等， 如果没有重写equals方法，则判断方式就按照‘==’判断 61.java注入bean有哪几种方式？ Javabean注入有两种方式： 构造函数注入，set/get方式注入 Spring注入bean有如下几种方式： Xml注入；使用注解@Autowired； 使用java方式注入；通过构建applicationContext对象方式注入 62.Bean 注入循环如何解决？ Spring的ioc容器会进行检查，如果是通过xml中通过set属性注入, 对于不是propertype属性注入的bean，spring可以提前缓存创建的bean，如果存在就直接使用。 63.Mybatis有遇到什么技术难点？ 其实也没有什么技术难点，基本遇到的问题都能及时解决，例如sql中&lt;,&gt; 号，sql结尾加了；，没有写#号等等， 都能根据报错提示很快定位并进行修正。 64.Mybatis 都用过哪些插件？ 简单介绍下如何使用的？ Mybatis-generators 自动生成dao,xml,bean的反向生成插件 Mybatis-plugins 自动关联dao,xml文件，并可以检测属性值是否错误 Mybatis-pagehelper 分页插件， 是通过spring的aop实现的，可以在执行sql的时候，把相关数据在执行一遍， 将当前表作为临时表，预编译sql之后执行 65.Aop如何实现事务的？ Aop方式可以在xml配置中体现出来，通过配置增强来实现事务的配置； 但是还有一种比较方便的配置方式，在xml中配置一行代码tx:annotation-driven , 然后在要实现事务的方法上添加@transaction注解， 事务回滚的情况，超时，抛异常都会导致事务回滚 66.如何根据key值找到map数组的下标？ Map底层是数组存储，那么数组的下标和扩容是如何做的？如何判断不会超出？ 首先存储的时候，根据key值通过散列算法得出对应的下标，算法会尽可能随机均匀的将数据分布在每个数组下，而扩容时根据对应的算法进行实现。 https://www.cnblogs.com/williamjie/p/9358291.html 67.线程的wait, sleep 方法是干什么用的？ sleep方法： 属于Thread类中的方法；会导致程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持着，当指定时间到了之后，又会自动恢复运行状态；在调用sleep方法的过程中，线程不会释放对象锁。（只会让出CPU，不会导致锁行为的改变） wait方法： 属于Object类中的方法；在调用wait方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify方法后本线程才进入对象锁定池准备。获取对象锁进入运行状态。（不仅让出CPU，还释放已经占有的同步资源锁） 68.线程使用wait之前， 线程都干了什么？ 添加同步锁，wait则是释放当前同步锁，并让出cpu资源 https://my.oschina.net/HerrySun/blog/714156 69.那么wait 和notify，是和什么配合使用的？ Synchronized 70.Java线程同步有哪几种方式？ lock与synchronized的区别？ 1.使用volitail, 2.使用wait , nofity, 3.使用synchronized, 4.使用ThreadLocal线程变量 ---------------------------------------------------------------------- 1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类； 2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； 3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； 5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） 6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 71.Java类加载过程？ Jvm将.java文件编译成…class文件，然后通过classloader类加载器将类信息加载到虚拟机内存中，在使用的时候在去创建这个对象。 72.多线程高并发做过么？ 高并发： 高并发是一种状态，如果大量请求访问网关接口。这种情况会发生大量执行操作，如数据库操作、资源请求、硬件占用等。这就需要对接口进行优化，而多线程是处理高并发的一种手段 多线程：是一种异步处理的一种方式，在同一时刻最大限度的利用计算机资源 73.微服务了解么？ 微服务架构系统是一个分布式系统，按照业务划分不同的组件或应用，可以独立部署和使用 74.多线程里面的参数都有哪些？ 分别代表什么意思？ 核心线程数，最大线程数，线程存活时间，线程队列 比如去火车站买票, 有10个售票窗口, 但只有5个窗口对外开放. 那么对外开放的5个窗口称为核心线程数, 而最大线程数是10个窗口.如果5个窗口都被占用, 那么后来的人就必须在后面排队, 但后来售票厅人越来越多, 已经人满为患, 就类似于线程队列已满.这时候火车站站长下令, 把剩下的5个窗口也打开, 也就是目前已经有10个窗口同时运行. 后来又来了一批人,10个窗口也处理不过来了, 而且售票厅人已经满了, 这时候站长就下令封锁入口,不允许其他人再进来, 这就是线程异常处理策略.而线程存活时间指的是, 允许售票员休息的最长时间, 以此限制售票员偷懒的行为. 75.ThreadLocal有用过么？ 将私有线程和该线程存放的副本对象做一个映射，各个线程变量之间互不影响，不共享数据，线程安全，一般存储为静态类型，可以在其他地方进行调用 76.Java异常有那几大类？Java异常类一般怎么抛出的？你是如何处理OutOfMemoryError异常的？ 非检查异常：Error 和 RuntimeException 以及他们的子类；这样的异常多半是代码写的有问题， 数组越界，强制类型转换等。 检查异常：除了Error 和 RuntimeException 以及他们的子类之外的异常；程序本身运行环境中出现的异常，需要使用try … catch扑捉。 内存溢出博文：http://outofmemory.cn/c/java-outOfMemoryError 导致OutOfMemoryError异常的常见原因有以下几种： 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 代码中存在死循环或循环产生过多重复的对象实体； 使用的第三方软件中的BUG； 启动参数内存值设定的过小 错误常见的错误提示： tomcat:java.lang.OutOfMemoryError: PermGen space tomcat:java.lang.OutOfMemoryError: Java heap space weblogic:Root cause of ServletException java.lang.OutOfMemoryError resin:java.lang.OutOfMemoryError java:java.lang.OutOfMemoryError 需要重点排查以下几点： 检查代码中是否有死循环或递归调用。 检查是否有大循环重复产生新对象实体。 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。 检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。 77.Jira插件有用过么？ 78.Dubbo简单介绍下，另外项目中有用过么？ 怎么用的？ Dubbo的使用方式： （1）导入dubbo、zookeeper依赖 （2）在服务提供者端，编写服务接口，服务接口的实现类，编写配置文件 （3）修改web.xml读取配置文件 （4）在服务消费者，即客户端，调用服务接口，调用服务实现类，编写配置文件 这样系统间就可以互相通信，从而感觉像在本地使用一样。 调用流程： · 服务容器负责启动，加载，运行服务提供者。 · 服务提供者在启动时，向注册中心注册自己提供的服务。 · 服务消费者在启动时，向注册中心订阅自己所需的服务。 · 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 · 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 · 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 79.介绍下常用的数据结构？ 枚举（Enumeration） 位集合（BitSet） 向量（Vector） 栈（Stack） 字典（Dictionary） 哈希表（Hashtable） 属性（Properties） 数组array 链表linkedList Collection Map 80.分布式事务介绍下？ 简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 81.arratlist查询比linkedlist快是因为一个是数组，一个是链表存储，数组下表具有连续性，可以通过偏移量查询，链表存储内存是不连续的，需要通过全部便利查询]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx常用命令]]></title>
    <url>%2F2019%2F08%2F20%2F%E7%8E%AF%E5%A2%83%2Fliunx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[liunx常用命令 su root 切换root用户 上传文件需要切换到root用户\ wget www.baidu.com 下载文件 解压.tgz结尾文件： tar -zxvf 文件名.tgz jar -cvf jar包名.jar 【指定目录或*.class】 tar -zxf hadoop-2.7.1-src.tar.gz -C …/softwares/ 解压压缩包到指定位置wad yum install -y lrzsz 通过yum命令安装上传文件命令, 安装好以后, 可以通过rz命令来打开窗口选择解压包 scp -r zookeeper-3.4.9/ @s202:/usr/local/ 远程copy文件[夹]到其他主机上 远程复制: scp -r core-site.xml hdfs-site.xml slaves ej@hadoop-slave1:/opt/work/cdh/hadoop/etc/hadoop/ 1234//临时关闭防火墙systemctl stop firewalld//禁止开机启动systemctl disable firewalld ===================================================== liunx常用编辑命令vim ; 关机命令： init 0 ; halt 重启命令： init 6 ; reboot 管道符号用法： 追加/覆盖： &gt;&gt; &gt; — 把前一个的输出结果追加/覆盖到某一个文件里面 liunx各版本下载地址 ： fedora版本桌面好看 使用ifconfig 总是过一段时间看不到ip, 解决方案是配置静态ip: 123456789101112131415编辑文件： sudo vi /etc/network/interfaces, 添加如下配置，ip地址改下auto loiface lo inet loopbackauto ens33iface ens33 inet staticaddress 192.168.57.129netmask 255.255.255.0gateway 192.168.57.2dns-nameserver 8.8.8.8 b) 重启网卡服务（2步）： sudo /etc/init.d/networking restart sudo systemctl restart network-manager.service c) 重启虚拟机，使用ifconfig查看]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop 搭建常用命令记录]]></title>
    <url>%2F2019%2F08%2F20%2F%E7%8E%AF%E5%A2%83%2Fhadoop%20%E6%90%AD%E5%BB%BA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[hadoop 搭建 常用命令记录 快捷键安装在/user/local/bin目录下 nano 文件名 ctrl + k 剪切一行 ctrl + o 保存并重命名，不重命名直接enter ctrl + x 退出 ctrl + u 粘贴 启动： start-dfs.sh + start-yarn.sh hdfs 文件目录 root01的：/usr/local/centos/hadoophdfs 文件目录 root01的：/usr/local/centos/hadoop 修改hdfs文件目录的权限： hdfs dfs -chmod 777 /usr/local/centos/hadoop修改hdfs文件目录的权限： hdfs dfs -chmod 777 /usr/local/centos/hadoop hdfs 特点： 支持大文件存储 流式数据访问 商用硬件【遇到故障不会明显感到中断，照样可以使用】 低时间延迟的数据访问【几十毫秒以内的响应不适合hdfs上运行，可使用hbase】 大量的小文件 多用户写入， 任意修改文件【不支持多用户同时写入同一个文件】 linux下打开eclipse , 在eclipse安装解压目录下， 用命令 ./eclipse &amp; 打开 hadoop API Configuration //配置类 fs.defaultFS (file:///) FileSystem //抽象类 核心配置文件 core-site.xml //文件系统+本地临时目录 hadoop.tmp.dir hdfs-site.xml //relication = 3 mapred-site.xml //yarn yarn-site.xml //rm blocksize 128m 寻址时间 ~=10 磁盘io速度= 100M/s 寻址时间是读取时间的1% centos hadoop hadoop/share/hadoop/common|hdfs|yarn|mapred|…/lib/jars window 与linux 之间共享文件夹目录， 可以存放文件共享并保持读写 $ sudo mount -t cifs -o username=Jinc,password=ej //192.160.12.103/linux_share window_share 注： linux下共享目录在 /usr/local/window_share , window下共享目录在E:/linux_share , 查看hadoop文件 内容 hadoop fs -text /usr/local/centos/hadoop/out_words/part-r-00000 复制文件到hadoop文件系统 hadoop fs -put words /usr/local/centos/hadoop/words 运行mapreduce， 将java导出jar文件在hadoop上运行，并将结果输出到另一个地方【前路径是要加载的文件，后路径是要计算后输出的文件位置，这个位置不能存在】 hadoop jar MR.jar cn.demo.WordCount /usr/local/centos/hadoop/words /usr/local/centos/hadoop/out_words 另一种执行mapredce的方法： bin/yarn jar test_data/hdfs-project.jar /input /usr/local/hadoop/wsssss IntWritable , Text , LongWritable java中int = IntWritable .get(); new IntWritable(num); 注： mapreduce 又几个重写方法， map, reduce， setup, cleanup , 其中， 最先执行的是setup, 然后是map,reduce ， 其次是cleanup 【这些都是内部类执行的顺序】]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ssm+ssh框架原理介绍]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%2Fssm%2Bssh%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[为什么使用HandlerAdapter? SpringMVC使用一个Servlet(DispacherServlet)代理所有的请求 , SpringMVC中的处理器是方法级别的处理器，而非类级别的处理，这样只要不定义类变量，就很容易在单例的情况下保证线程安全。同时对处理器进行统一封装，最大程度重用代码。 总结流程 12345678910111213141516171819 Spring工作流程描述 1. 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获； 2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； 3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法） 4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 5. Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 6. 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； 7. ViewResolver 结合Model和View，来渲染视图 8. 将渲染结果返回给客户端。Spring工作流程描述 为什么Spring只使用一个Servlet(DispatcherServlet)来处理所有请求？ 详细见J2EE设计模式-前端控制模式 Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler? 符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。 springmvc 与struts2对比 struts2是类级别的拦截， 一个类对应一个request上下文， springmvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应 所以说从架构本身上 spring3 mvc就容易实现restful url 而struts2的架构实现起来要费劲 因为struts2 action的一个方法可以对应一个url 而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了 spring3mvc的方法之间基本上独立的，独享request response数据 请求数据通过参数获取，处理结果通过ModelMap交回给框架 方法之间不共享变量 而struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的 这不会影响程序运行，却给我们编码 读程序时带来麻烦 由于Struts2需要针对每个Request进行封装，把Request，Session等Servlet生命周期的变量封装成一个一个Map， 供给每个Action使用，并保证线程安全。所以在原则上，是比较耗费内存的. 运行性能上： Jsp+servlet&gt;struts1&gt;spring mvc&gt;struts2+freemarker&gt;&gt;struts2,ognl,值栈。 开发效率上,基本正好相反。值得强调的是，spring mvc开发效率和struts2不相上下。 Struts2的性能低的原因是因为OGNL和值栈造成的。所以，如果你的系统并发量高，可以使用freemaker进行显示，而不是采用OGNL和值栈。这样，在性能上会有相当大得提高。 Struts2的优点 Struts2 是一个相当强大的Java Web开源框架，是一个基于POJO的Action的MVC Web框架。它基于当年的Webwork和XWork框架，继承其优点，同时做了相当的改进。 1、Struts2基于MVC架构,框架结构清晰，开发流程一目了然，开发人员可以很好的掌控开发的过程。(开发人员可以把大部分关注点转移到业务逻辑的实现上) 2、使用OGNL进行参数传递。(使用标签可以更方便的访问各个域或者参数的值) 3、强大的拦截器.(异常处理，文件上传，登录验证，权限验证) 看完了Spring是什么，再来看看Spring有哪些优点 Spring是一个轻量级的ioc(控制反转)和AOP(依赖注入)容器框架。 使用Spring的IOC容器，将对象之间的依赖关系交给Spring，降低组件之间的耦合性，让我们更专注于应用逻辑 可以提供众多服务，事务管理，WS等。 AOP的很好支持，方便面向切面编程。 对主流的框架提供了很好的集成支持，如hibernate,Struts2,JPA等 Spring DI机制降低了业务对象替换的复杂性。 Spring属于低侵入，代码污染极低。 Spring的高度可开放性，并不强制依赖于Spring，开发者可以自由选择Spring部分或全部 Hibernate优点 对象/关系数据库映射(ORM) 它使用时只需要操纵对象，使开发更对象化，抛弃了数据库中心的思想，完全的面向对象思想 透明持久化(persistent) 带有持久化状态的、具有业务功能的单线程对象，此对象生存期很短。这些对象可能是普通的JavaBeans/POJO，这个对象没有实现第三方框架或者接口，唯一特殊的是他们正与（仅仅一个）Session相关联。一旦这个Session被关闭，这些对象就会脱离持久化状态，这样就可被应用程序的任何层自由使用。（例如，用作跟表示层打交道的数据传输对象。） 事务Transaction(org.hibernate.Transaction) 应用程序用来指定原子操作单元范围的对象，它是单线程的，生命周期很短。它通过抽象将应用从底层具体的JDBC、JTA以及CORBA事务隔离开。某些情况下，一个Session之内可能包含多个Transaction对象。尽管是否使用该对象是可选的，但无论是使用底层的API还是使用Transaction对象，事务边界的开启与关闭是必不可少的。 它没有侵入性，即所谓的轻量级框架 移植性会很好 缓存机制，提供一级缓存和二级缓存 简洁的HQL编程 Hibernate缺点 Hibernate在批量数据处理时有弱势 针对单一对象简单的增删查改，适合于Hibernate,而对于批量的修改，删除，不适合用Hibernate,这也是OR框架的弱点；要使用数据库的特定优化机制的时候，不适合用Hibernate 这里有更详细的： http://blog.sina.com.cn/s/blog_4fef5df10100nxmm.html Hibernate的优缺点： 优点：1、程序更加面向对象； 2、提高了生产率； 3、方便移植（修改配置文件）； 4、无侵入性。 缺点： 1、效率比JDBC略差； 2、不适合批量操作。 hibernate适用场景 hibernate只适合做中小型项目,因为其性能是个大问题,ps:当然能把hibernate性能优化的很好是例外, Hibernate有四种查询方案： get,load方法，根据id查找对象; 注:区别(1) .get是直接到数据库查询;load是生成一个代理,用的时候在去查,性能好点 2). get使用id获取对象不存在,报null指针异常, load不会) HQL–hibernate query language（查询对象：Query) Criteria–标准查询语言（查询对象：Criteria，查询条件：Criterion） 通过sql来查（查询对象：SQLQuery）]]></content>
      <categories>
        <category>技术原理</category>
      </categories>
      <tags>
        <tag>技术原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池简单用法]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2F%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高并发多线程插入数据写法示例 使用方法 123456789101112// 固定声明10个线程private ExecutorService executorService = Executors.new FixedThreadPool(10);private ThreadPoolExecutor executor = (ThreadPoolExecutor)executorService;// 使用队列插入数据，后面如果改造成批处理之类的也好执行private LinkedBlockingDeque&lt;DataModel&gt; queue = new LinkedBlockingDeque&lt;DataModel&gt;();private void insertRecord(DataModel dataModel)&#123; queue.add(queryModel); InsertRecordThread task = new InsertRecordThread(jjgExamQuesLoadDao, queue); executor.execute(task);&#125;// 这里不用executor.shutdown(),关闭线程池 ， 因为线程池一直开着，没有就不会启用，用就可以直接执行， 不要将线程池关闭。 线程执行类 12345678910111213141516171819202122public class InsertRecordThread implements Runnable&#123; private JjgExamQuesLoadDao jjgExamQuesLoadDao; private LinkedBlockingDeque&lt;DataModel&gt; queue; public InsertRecordThread(JjgExamQuesLoadDao jjg , LinkedBlockingDeque&lt;DataModel&gt; queue)&#123; this.jjgExamQuesLoadDao = jjg; this.queue = queue; &#125; public void run()&#123; try&#123; DataModel event = queue.poll(); jjgExamQuesLoadDao.insertAnswerRecord(event); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 到此项目结束， 之前因为不太会用多线程，总感觉会出现问题，不敢用，其实用多了，考虑周全也没什么问题， 而且效率还会大大提升。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模拟多ip请求]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2F%E6%A8%A1%E4%BB%BF%E5%A4%9Aip%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[模仿多ip并发访问某个地址 package url_demo; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.URL; import java.net.URLConnection; import java.util.Random; public class HttpUtilTest { private int index = 0; public String sendPost(String url, String param) { PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; try { URL realUrl = new URL(url); URLConnection conn = realUrl.openConnection(); // 随机生成ip String ip = randIP(); conn.setRequestProperty(&quot;X-Forwarded-For&quot;, ip); conn.setRequestProperty(&quot;HTTP_X_FORWARDED_FOR&quot;, ip); conn.setRequestProperty(&quot;HTTP_CLIENT_IP&quot;, ip); conn.setRequestProperty(&quot;REMOTE_ADDR&quot;, ip); conn.setRequestProperty(&quot;Host&quot;, &quot;&quot;); conn.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;); conn.setRequestProperty(&quot;Content-Length&quot;, &quot;17&quot;); conn.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;); conn.setRequestProperty(&quot;Origin&quot;, &quot;ORIGIN&quot;); conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); conn.setRequestProperty(&quot;Referer&quot;, &quot;REFERER&quot;); conn.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip, deflate&quot;); conn.setRequestProperty(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en;q=0.6,ja;q=0.4,pt;q=0.2&quot;); conn.setDoOutput(true); conn.setDoInput(true); out = new PrintWriter(conn.getOutputStream()); out.print(param); out.flush(); in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) { result += line; } synchronized (this) { DemoUtl.index = DemoUtl.index + 1; } System.out.println(&quot;第&quot; + DemoUtl.index + &quot;次访问； --&gt; || 当前线程：&quot; + param + &quot; || 请求成功！ || 模拟ip: &quot; + ip + &quot; || 返回结果： &quot; + result.toString().hashCode()); } catch (Exception e) { // System.out.println(&quot;发送 POST 请求出现异常！&quot; + e); // e.printStackTrace(); } finally { try { if (out != null) { out.close(); } if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } return result; } public static String randIP() { Random random = new Random(System.currentTimeMillis()); return (random.nextInt(255) + 1) + &quot;.&quot; + (random.nextInt(255) + 1) + &quot;.&quot; + (random.nextInt(255) + 1) + &quot;.&quot; + (random.nextInt(255) + 1); } } package url_demo; import java.util.Random; public class DemoUtl { public static int index = 0; public static void main(String[] args) throws InterruptedException { try { for (int i = 0; i &lt; 100000; i++) { Thread.sleep((new Random()).nextInt(200) + 100); new Thread(new Runnable() { @Override public void run() { for (int j = 0; j &lt; 100000; j++) { try { Thread.sleep((new Random()).nextInt(3200) + 1500); HttpUtilTest tt = new HttpUtilTest(); tt.sendPost( &quot;https://www.baidu.com&quot;, Thread.currentThread().getName()); } catch (InterruptedException e) { e.printStackTrace(); } } } }).start(); } } catch (Exception e) { e.printStackTrace(); } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mq集群方式搭建]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2Frocketmq%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[mq集群方式搭建 有段时间没写这些技术文章了， 今天抽空写一点，不然自己都快忘记了 这篇文章记录了rocketmq 集群方式搭建的过程， 也是自己半天的成果记录吧！ 感兴趣的朋友点个赞在走呗！ 好了，废话不多，下面开搞。 本文章参考https://blog.csdn.net/qq_35400008/article/details/82467562#comments 这个博客文章编写 准备工作 第一步：关闭要搭建的所有机器的防火墙 第二步：每台机器执行下如下步骤 12345[root@ma01 ~]# vim /etc/sysconfig/selinux......SELINUX=disabled[root@ma01~]# setenforce 0[root@ma01~]# getenforce 第三步：所有机器装好jdk, maven , zip , unzip , ssh 免密登录 12345配置crt连接： https://blog.csdn.net/cmqwan/article/details/61932792安装maven参考老哥博客: https://www.cnblogs.com/clicli/p/5866390.html安装zip,unzip参考： http://www.rpmfind.net/linux/rpm2html/search.php?query=zip&amp;submit=Search+...&amp;system=&amp;arch=安装ssh参考： https://blog.csdn.net/m0_37590135/article/details/74275859jdk自己百度哈， 很多参考博客的！ 第四步： 如下命令是ssh机器之间copy用的命令 1scp -r /home/administrator/test/ root@192.168.1.100:/root/ 第五步： 下载完成后， 解压 1unzip rocketmq-all-4.4.0-bin-release.zip 第六步：进入解压后的文件夹rocketmq-bin4.4.0 , 在文件夹里面新建logs , data/store, data2/store 目录 第七步：安装顺序修改bin下面的几个启动文件， 因默认配置内存空间太大，本地启动会报错 1231. vim runbroker.sh 对应地方更改为 -server -Xms512m -Xmx512m -Xmn256m2. vim runserver.sh (同样的道理） -server -Xms512m -Xmx512m -Xmn126m -XX:PermSize=128m -XX:MaxPermSize=320m3. vim tools.sh -server -Xms256m -Xmx256m -Xmn128m -XX:PermSize=128m -XX:MaxPermSize=128m 第八步：到rocketmq-bin4.4.0/conf/2m-2s-async 下 修改这四个文件 注： 这里说明下哈， 我是用了三台机器，所有配置了130， 131和132一样的，你们2台机器完全可以用，131和132配置一台就可以了哈，ip自行更改哈。 第九步： 130主机器修改如下配置文件， broker-a.properties broker-b-s.properties两个文件 内容分别如下 broker-a.properties 12345678910111213141516171819202122232425262728293031323334353637383940brokerClusterName=RocketMQClusterbrokerName=broker-abrokerId=0deleteWhen=04fileReservedTime=48brokerRole=ASYNC_MASTERflushDiskType=ASYNC_FLUSH##Broker 对外服务的监听端口listenPort=10911#nameserver地址，分号分割namesrvAddr=192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=truebrokerIP1=192.168.175.130storePathRootDir=/opt/local/data/install/rocketmq-bin4.4.0/data/storestorePathCommitLog=/opt/local/data/install/rocketmq-bin4.4.0/data/store/commitlog# 消费队列存储路径存储路径storePathConsumerQueue=/opt/local/data/install/rocketmq-bin4.4.0/data/store/consumequeue#消息索引存储路径storePathIndex=/opt/local/data/install/rocketmq-bin4.4.0/data/store/index#checkpoint 文件存储路径storeCheckpoint=/opt/local/data/install/rocketmq-bin4.4.0/data/store/checkpoint#abort 文件存储路径abortFile=/opt/local/data/install/rocketmq-bin4.4.0/data/store/abort#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120# commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存300W条，根据业务情况调整mapedFileSizeConsumeQueue=3000000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间#diskMaxUsedSpaceRatio=88 broker-b-s.properties 123456789101112131415161718192021222324252627282930313233343536373839brokerClusterName=RocketMQClusterbrokerName=broker-bbrokerId=1deleteWhen=04fileReservedTime=48brokerRole=SLAVEflushDiskType=ASYNC_FLUSHlistenPort=10921#nameserver地址，分号分割namesrvAddr=192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876brokerIP1=192.168.175.130#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=truestorePathRootDir=/opt/local/data/install/rocketmq-bin4.4.0/data2/storestorePathCommitLog=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/commitlog2# 消费队列存储路径存储路径storePathConsumerQueue=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/consumequeue2#消息索引存储路径storePathIndex=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/index2#checkpoint 文件存储路径storeCheckpoint=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/checkpoint2#abort 文件存储路径abortFile=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/abort2#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120# commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存300W条，根据业务情况调整mapedFileSizeConsumeQueue=3000000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间#diskMaxUsedSpaceRatio=88 第十步： 131， 132 机器只修改 broker-b.properties 和broker-a-s.properties 内容分别如下： broker-b.properties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# limitations under the License.brokerClusterName=RocketMQClusterbrokerName=broker-bbrokerId=0deleteWhen=04fileReservedTime=48brokerRole=ASYNC_MASTERflushDiskType=ASYNC_FLUSHlistenPort=10911#nameserver地址，分号分割namesrvAddr=192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876brokerIP1=192.168.175.131#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=truestorePathRootDir=/opt/local/data/install/rocketmq-bin4.4.0/data/storestorePathCommitLog=/opt/local/data/install/rocketmq-bin4.4.0/data/store/commitlog# 消费队列存储路径存储路径storePathConsumerQueue=/opt/local/data/install/rocketmq-bin4.4.0/data/store/consumequeue#消息索引存储路径storePathIndex=/opt/local/data/install/rocketmq-bin4.4.0/data/store/index#checkpoint 文件存储路径storeCheckpoint=/opt/local/data/install/rocketmq-bin4.4.0/data/store/checkpoint#abort 文件存储路径abortFile=/opt/local/data/install/rocketmq-bin4.4.0/data/store/abort#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120# commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存300W条，根据业务情况调整mapedFileSizeConsumeQueue=3000000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间#diskMaxUsedSpaceRatio=88 broker-a-s.properties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# limitations under the License.brokerClusterName=RocketMQClusterbrokerName=broker-abrokerId=1deleteWhen=04fileReservedTime=48brokerRole=SLAVEflushDiskType=ASYNC_FLUSHlistenPort=10921namesrvAddr=192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876brokerIP1=192.168.175.131#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=truestorePathRootDir=/opt/local/data/install/rocketmq-bin4.4.0/data2/storestorePathCommitLog=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/commitlog# 消费队列存储路径存储路径storePathConsumerQueue=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/consumequeue#消息索引存储路径storePathIndex=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/index#checkpoint 文件存储路径storeCheckpoint=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/checkpoint#abort 文件存储路径abortFile=/opt/local/data/install/rocketmq-bin4.4.0/data2/store/abort#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120# commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存30W条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间#diskMaxUsedSpaceRatio=88 第十一步： 启动 1234567891011121314三台都执行：nohup sh bin/mqnamesrv &gt; ./logs/namesrvrun.log 2&gt;&amp;1 &amp;130机器执行： nohup sh bin/mqbroker -c conf/2m-2s-async/broker-a.properties -n"192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876" &gt; ./logs/broker-a.log 2&gt;&amp;1 &amp;nohup sh bin/mqbroker -c conf/2m-2s-async/broker-b-s.properties -n"192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876" &gt; ./logs/broker-b-s.log 2&gt;&amp;1 &amp;131， 132 机器执行：nohup sh bin/mqbroker -c conf/2m-2s-async/broker-b.properties -n"192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876" &gt; ./logs/broker-b.log 2&gt;&amp;1 &amp;nohup sh bin/mqbroker -c conf/2m-2s-async/broker-a-s.properties -n"192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876" &gt; ./logs/broker-a-s.log 2&gt;&amp;1 &amp; 执行之后，jps结果，有两个brokerstartup就行了， 如果报错的化，看下自己建的logs文件夹日志 好了，到此rocketmq 基础配置就搭建起来了，下面在讲一讲实战代码 导入依赖包 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-client --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-all&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; mq消息发送方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.io.UnsupportedEncodingException;import org.apache.rocketmq.client.exception.MQBrokerException;import org.apache.rocketmq.client.exception.MQClientException;import org.apache.rocketmq.client.producer.DefaultMQProducer;import org.apache.rocketmq.client.producer.SendResult;import org.apache.rocketmq.common.message.Message;import org.apache.rocketmq.remoting.common.RemotingHelper;import org.apache.rocketmq.remoting.exception.RemotingException;/** * 消息发送者 * @author LELE * */public class Producer &#123; public static void main(String[] args) throws MQClientException, InterruptedException &#123; // 声明并初始化一个producer // 需要一个producer group名字作为构造方法的参数，这里为producer1 DefaultMQProducer producer = new DefaultMQProducer("producer1"); producer.setVipChannelEnabled(false); // 设置NameServer地址,此处应改为实际NameServer地址，多个地址之间用；分隔 // NameServer的地址必须有 // producer.setClientIP("xxxx"); // producer.setInstanceName("Producer"); producer.setNamesrvAddr("192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876"); // 调用start()方法启动一个producer实例 producer.start(); // 发送1条消息到Topic为TopicTest，tag为TagA，消息内容为“Hello RocketMQ”拼接上i的值 try &#123; for(int i=0;i&lt;30000;i++) &#123; // 封装消息 Message msg = new Message("TopicTest", // topic "TagA", // tag ("Hello RocketMQ--------"+i).getBytes(RemotingHelper.DEFAULT_CHARSET)// body ); // 调用producer的send()方法发送消息 // 这里调用的是同步的方式，所以会有返回结果 SendResult sendResult = producer.send(msg); // 打印返回结果 System.out.println(sendResult); &#125; &#125; catch (RemotingException e) &#123; e.printStackTrace(); &#125; catch (MQBrokerException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; // 发送完消息之后，调用shutdown()方法关闭producer System.out.println("send success"); producer.shutdown(); &#125;&#125; 消息消费者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.List;import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;import org.apache.rocketmq.client.exception.MQClientException;import org.apache.rocketmq.common.consumer.ConsumeFromWhere;import org.apache.rocketmq.common.message.MessageExt;/** * 消息接收者， 需要服务器启动mq服务 * @author LELE * */public class Consumer &#123; public static void main(String[] args) throws MQClientException &#123; // 声明并初始化一个consumer // 需要一个consumer group名字作为构造方法的参数，这里为consumer1 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("consumer1"); // consumer.setVipChannelEnabled(false); // 同样也要设置NameServer地址 consumer.setNamesrvAddr("192.168.175.130:9876;192.168.175.131:9876;192.168.175.132:9876"); // 这里设置的是一个consumer的消费策略 // CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息 // CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍 // CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); // 设置consumer所订阅的Topic和Tag，*代表全部的Tag consumer.subscribe("TopicTest", "*"); // 设置一个Listener，主要进行消息的逻辑处理 consumer.registerMessageListener(new MessageListenerConcurrently() &#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123; MessageExt msg = msgs.get(0); if (msg.getTopic().equals("TopicTest")) &#123; // 执行TopicTest1的消费逻辑 System.out.println("TagA:" + new String(msg.getBody())); &#125; System.out.println(Thread.currentThread().getName() + " Receive New Messages: " + msgs.size() + "----------------------------------------------------------------------------------"); // 返回消费状态 // CONSUME_SUCCESS 消费成功 // RECONSUME_LATER 消费失败，需要稍后重新消费 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125; &#125;); // 调用start()方法启动consumer consumer.start(); System.out.println("Consumer Started."); &#125;&#125; 启动开始尽情玩耍吧，少年， 记得点赞哦！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle经典语法]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2Foracle%E7%BB%8F%E5%85%B8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[各种树操作， 用来查询表中带有子父节点的信息 Oracle 树操作(select…start with…connect by…prior) 1234select m.org_idfrom sm_organ mstart with m.org_id = '00000'connect by prior m.org_id = m.parent_org_id; [查询org_id为‘00000’的所有父节点，并按倒叙排序] 12345678select distinct root,root_leve,org_Idfrom(select sys_connect_by_path (org_id, '/') as PATH,connect_by_root(org_id) as root,connect_by_root(org_leve) as root_leve,t.*from sm_ORGAN tstart with org_leve IN ('3')connect by NOCYCLE parent_org_id = prior org_id) a ; 模糊查询(||是连接符) 1SUB.AU_OPER LIKE '%'||#auOper#||'%' AND oracle数据库中日期进行比较 1234createDate = to_date(sysdate,'yy-MM-dd hh24:mi:ss') 或者直接比较 createDate &gt; '2013-09-08 00:00:00' 或者 createDate = to_date('','yyyyMMdd') 或者 createDate = date'2016-09-09' Oracle数据库中chr()、ascii()、asciistr()、convert()函数的使用 ,nvl() nvl(字段名,‘判断字段如果为空的话这里填你想要替换的值’) to_date( NVL2(T1.txdonetime, substr(T1.txdonetime,0,14), ‘’),‘yyyy-MM-dd hh24:mi:ss’) txdonetime , varchar2类型日期转换date nvl(字段,‘NA’) 意思如果字段为空则输出NA的字符串 12345678910111213141516-- 将查询字段中的name名称中部分汉字转换成想要的结果SELECT replace( replace( replace('xxxxxxxxxxxxxxxxxxxxx', ''|| chr(15xxxx92) || chr(1524xx81) ||chr(1xxxx521) || chr(15xxxx814) ||chr(1xxxx592) || '', ''), ''|| chr(1xxxx02) || chr(1xxxx485) || chr(149xxxx48) || chr(14xxxx6) || chr(153xxxx92) || '', ''), ''|| chr(150xxxx3) || chr(15xxxxx425) || chr(x770xxx2) ||chr(15xxxx08) || '', '') ORG_xxxx FROM SMS_xxxxx ORG WHERE 1 = 1 AND ORG_xxxx = '0951' ; select ''|| chr(15252223392) ||chr(1225303592) || '' aa from dual; -- 拼接字符串select ascii('国') aa from dual; -- 将汉字转为数字select chr(15047613) bb from dual; --将数字转为汉字select replace('111123224455', '22' , '44') aa from dual; --替换字符串中的字符select asciistr('国汉字之都') aa from dual; --将一串字符串转为中文编码 \56FD\6C49\5B57\4E4B\90FDselect convert('在中国','zhs16gbk','utf8') aa from dual; --将字符串从一种字符转为另一种字符 使用 WM_CONCAT(us.USeER_ID) 函数可以将单组查询结果转为一列一行, 数据中间用 &quot; , &quot;分隔 1select WM_CONCAT(us.USeER_ID) USERS from sm_euser us where us.oreg_id = '0200' ; 建表之前先判断表是否存在 , 若存在,则删除 12345678declare num number;begin select count(1) into num from user_tables where table_name = upper('sys_area') ; if num &gt; 0 then execute immediate 'drop table sys_area' ; end if;end; 使用oracle若信息存在,则更新, 若不存在, 则插入 [merge into 大数据量的话可以使用这个优化] 123456789101112131415161718192021merge into BOS_PARA_CONL_RULES ausing bos_para_codel_info bon (a.modeel_no = b.model_no)when MATCHED then update set trade_system = #tradeSystem#, trade_name = #tradeName#, note = #Note#, system_basis = #systemBasis# where b.modeel_no = #modelNo#When not matched then insert (TRADE_SYSTEM, TRADE_NAME, NOTE, SYSTEM_BASIS) values (#tradeSystem#, #tradeName#, #Note#, #systemBasis#) where b.modeel_no = #modelNo# TRUNC 函数的用法 12345678910111213141516171819--1 TRUNC（date[,fmt]） TRUNC（TO_DATE（'24-Nov-1999 08:37 pm','dd-mon-yyyy hh:mi am'），'hh'） ='24-Nov-1999 08:00:00 am' trunc（sysdate,'yyyy'） --返回当年第一天。 trunc（sysdate,'mm'） --返回当月第一天。 trunc（sysdate,'d'） --返回当前星期的第一天。 trunc（sysdate,'dd'）--返回当前年月日--2TRUNC（for number） TRUNC（number[,decimals]） 其中： number 待做截取处理的数值 decimals 指明需保留小数点后面的位数。可选项，忽略它则截去所有的小数部分 下面是该函数的使用情况： TRUNC（89.985，2）=89.98 TRUNC（89.985）=89 TRUNC（89.985，-1）=80 注意：第二个参数可以为负数，表示为小数点左边指定位数后面的部分截去，即均以0记。与取整类似，比如参数为1即取整到十分位，如果是-1，则是取整到十位，以此类推。 Oracle trunc()函数的用法 12345678910111213141516171819202122232425--日期1.select trunc(sysdate) from dual --2011-3-18 今天的日期为2011-3-182.select trunc(sysdate, 'mm') from dual --2011-3-1 返回当月第一天.3.select trunc(sysdate,'yy') from dual --2011-1-1 返回当年第一天4.select trunc(sysdate,'dd') from dual --2011-3-18 返回当前年月日5.select trunc(sysdate,'yyyy') from dual --2011-1-1 返回当年第一天6.select trunc(sysdate,'d') from dual --2011-3-13 (星期天)返回当前星期的第一天7.select trunc(sysdate, 'hh') from dual --2011-3-18 14:00:00 当前时间为14:41 8.select trunc(sysdate, 'mi') from dual --2011-3-18 14:41:00 TRUNC()函数没有秒的精确--数字/*TRUNC（number,num_digits）Number 需要截尾取整的数字。Num_digits 用于指定取整精度的数字。Num_digits 的默认值为 0。TRUNC()函数截取时不进行四舍五入*/9. select trunc(123.458) from dual --12310.select trunc(123.458,0) from dual --12311.select trunc(123.458,1) from dual --123.412.select trunc(123.458,-1) from dual --12013.select trunc(123.458,-4) from dual --014.select trunc(123.458,4) from dual --123.45815.select trunc(123) from dual --12316.select trunc(123,1) from dual --12317.select trunc(123,-1) from dual --120 创建序列 123456789101112create sequence SEQ_xxOS_AUxxxED_FB_IDminvalue 1maxvalue 99999999999999999999start with 669408473increment by 1cache 20cycle;--SEQUENCEGRANT SELECT, ALTER ON SEQ_xxOS_AUxxxED_FB_IDxxOxxxETL;GRANT SELECT, ALTER ON SEQ_xxOS_AUxxxED_FB_IDxxxxxR;--SEQUENCE SYNONYMCREATE OR REPLACE PUBLIC SYNONYM SEQ_xxOS_AUxxxED_FB_IDFOR sxxS.SEQ_xxOS_AUxxxED_FB_ID; 动态菜单权限(至少需要5张表) 12345select * from xx_mxenu; //菜单表 select * from xx_UxER; //用户表select * from xx_SSxTEM_ROxLE; //角色表select * from xx_USxER_ROxLE; //用户角色表select * from xxEF_RxLE_MExNU; //角色菜单表 字典表可以做成2张表, 一张存储该字典字段的主题id, 另一张存放该主题id需要存储那些字典字段 12select * from bos_comm_field f where f.field_name='GET_CHECK_TYPE'; select * from bos_comm_code C WHERE C.CODE_TYPE='CHECK_TYPE' ; oracle的配置文件tnsnames.ora 里面内容可以改下自定义的, 例如下面开发库这么一长串数据库, =左边的可以自定义, 然后连接的时候数据库框就填左边的,相当于=右边的一长串 1210.10.10.100 = (DESCRIPTION =(ADDRESS=(PROTOCOL=TCP) (HOST = 10.10.10.100) (PORT=1234))(CONNECT_DATA=(SID=oredd))) xxx/123456 oracles数据库中创建表, 并赋予其他角色权限 1234--SYNONYMCREATE OR REPLACE PUBLIC SYNONYM xxxxxx表名 FOR 库名.xxxxxx表名;-- GRANT/REVOKE OBJECT PRIVILEGES GRANT SELECT, INSERT, UPDATE, DELETE ON xxxxxx表名 TO 用户名; id取值（序列+日期串） 1select to_char(sysdate, 'yyyymmdd')||lpad(seq_xxxxxtem_id.nextval,15, '0') from dual; 存储过程中删除表 1EXECUTE IMMEDIATE 'TRUNCATE TABLE TEMP_ITEM_ACC'; 未完后续补充中。。。。。。。。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mkdown 简单语法]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2FMkdown%20%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[这篇笔记停了两天，今天开始整理， 写这篇笔记主要是加强下自己的mkdown语法知识， 另外可以帮助到更多像我一样，每次用都要重新百度。 Mkdown 语法简介 标题 【h1 - h6】 12# ~ ######一般# 作为标题， 只有一个， ### 作为段落标题 上下文标题 1234AAA====BBB---- 强调 斜体 12*- 加粗 1** 删除线 1~~ 代码 代码块标记 1三个```即可 代码块缩进表示法 1Tab 或 四个空格 语法高亮显示 1三个```javascript 内嵌代码块 1` 表格 简约写法 123a | b | c:-:|:-|-: 居中 |左对齐 | 右对其 链接 内链式 1[百度](http://www.baidu.com/"百度一下")&#123;:target="_blank"&#125; 引用式 12[百度][2]&#123;:target="_blank"&#125;[2]:http://www.baidu.com/ "百度一下" 邮箱链接 1&lt;xxx@outlook.com&gt; 图片 内链式 1![name](./01.png '描述') 图片带有链接 1[![name](./01.png '百度')](http://www.baidu.com) 瞄点 12[公式标题锚点](#1)[需要跳转的目录] &#123;#1&#125; 脚注 12Markdown[^1][^1]: Markdown是一种纯文本标记语言。 github表情 😄 👍 👏 1:smile: :+1: :clap: 分割符 123***--- 本文内容总结来自: https://ouweiya.gitbooks.io/markdown/]]></content>
      <categories>
        <category>技术博客</category>
      </categories>
      <tags>
        <tag>mkdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka集群环境搭建]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2Fkafka%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[简单记录下kafka集群环境搭建过程， 用来做备忘录 安装 第一步： 点击官网下载地址 http://kafka.apache.org/downloads.html 下载最新安装包 第二步： 解压 1tar xvf kafka_2.12-2.2.0.tgz 第三步： 检查服务器有没有安装zookeeper集群， 没有的话，自行百度补充 第四步：修改config/server.properties 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# Licensed to the Apache Software Foundation (ASF) under one or more# contributor license agreements. See the NOTICE file distributed with# this work for additional information regarding copyright ownership.# The ASF licenses this file to You under the Apache License, Version 2.0# (the "License"); you may not use this file except in compliance with# the License. You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.# see kafka.server.KafkaConfig for additional details and defaults############################# Server Basics ############################## The id of the broker. This must be set to a unique integer for each broker.broker.id=0 // 说明，这个跟zookeeper的myid一样配置 0，1，2############################# Socket Server Settings ############################## The address the socket server listens on. It will get the value returned from # java.net.InetAddress.getCanonicalHostName() if not configured.# FORMAT:# listeners = listener_name://host_name:port# EXAMPLE:# listeners = PLAINTEXT://your.host.name:9092#listeners=PLAINTEXT://:9092host.name=192.168.175.130 // 当前服务器ip# Hostname and port the broker will advertise to producers and consumers. If not set, # it uses the value for "listeners" if configured. Otherwise, it will use the value# returned from java.net.InetAddress.getCanonicalHostName().#advertised.listeners=PLAINTEXT://your.host.name:9092# Maps listener names to security protocols, the default is for them to be the same. See the config documentation for more details#listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL# The number of threads that the server uses for receiving requests from the network and sending responses to the networknum.network.threads=3# The number of threads that the server uses for processing requests, which may include disk I/Onum.io.threads=8# The send buffer (SO_SNDBUF) used by the socket serversocket.send.buffer.bytes=102400# The receive buffer (SO_RCVBUF) used by the socket serversocket.receive.buffer.bytes=102400# The maximum size of a request that the socket server will accept (protection against OOM)socket.request.max.bytes=104857600############################# Log Basics ############################## A comma separated list of directories under which to store log fileslog.dirs=/opt/local/data/install/kafka2.2.0/log/kafka // 目录要存在# The default number of log partitions per topic. More partitions allow greater# parallelism for consumption, but this will also result in more files across# the brokers.num.partitions=1# The number of threads per data directory to be used for log recovery at startup and flushing at shutdown.# This value is recommended to be increased for installations with data dirs located in RAID array.num.recovery.threads.per.data.dir=1############################# Internal Topic Settings ############################## The replication factor for the group metadata internal topics "__consumer_offsets" and "__transaction_state"# For anything other than development testing, a value greater than 1 is recommended for to ensure availability such as 3.offsets.topic.replication.factor=1transaction.state.log.replication.factor=1transaction.state.log.min.isr=1############################# Log Flush Policy ############################## Messages are immediately written to the filesystem but by default we only fsync() to sync# the OS cache lazily. The following configurations control the flush of data to disk.# There are a few important trade-offs here:# 1. Durability: Unflushed data may be lost if you are not using replication.# 2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush.# 3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to excessive seeks.# The settings below allow one to configure the flush policy to flush data after a period of time or# every N messages (or both). This can be done globally and overridden on a per-topic basis.# The number of messages to accept before forcing a flush of data to disk#log.flush.interval.messages=10000# The maximum amount of time a message can sit in a log before we force a flush#log.flush.interval.ms=1000############################# Log Retention Policy ############################## The following configurations control the disposal of log segments. The policy can# be set to delete segments after a period of time, or after a given size has accumulated.# A segment will be deleted whenever *either* of these criteria are met. Deletion always happens# from the end of the log.# The minimum age of a log file to be eligible for deletion due to agelog.retention.hours=168# A size-based retention policy for logs. Segments are pruned from the log unless the remaining# segments drop below log.retention.bytes. Functions independently of log.retention.hours.#log.retention.bytes=1073741824# The maximum size of a log segment file. When this size is reached a new log segment will be created.log.segment.bytes=1073741824# The interval at which log segments are checked to see if they can be deleted according# to the retention policieslog.retention.check.interval.ms=300000############################# Zookeeper ############################## Zookeeper connection string (see zookeeper docs for details).# This is a comma separated host:port pairs, each corresponding to a zk# server. e.g. "127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002".# You can also append an optional chroot string to the urls to specify the# root directory for all kafka znodes.zookeeper.connect=192.168.175.130:2181,192.168.175.131:2181,192.168.175.132:2181 // 三台服务器配置# Timeout in ms for connecting to zookeeperzookeeper.connection.timeout.ms=6000############################# Group Coordinator Settings ############################## The following configuration specifies the time, in milliseconds, that the GroupCoordinator will delay the initial consumer rebalance.# The rebalance will be further delayed by the value of group.initial.rebalance.delay.ms as new members join the group, up to a maximum of max.poll.interval.ms.# The default value for this is 3 seconds.# We override this to 0 here as it makes for a better out-of-the-box experience for development and testing.# However, in production environments the default value of 3 seconds is more suitable as this will help to avoid unnecessary, and potentially expensive, rebalances during application startup.group.initial.rebalance.delay.ms=0 注： server.properties配置文件的修改主要在开头和结尾，中间保持默认配置即可；需要注意的点是broker.id的值三个节点要配 置不同的值，分别配置为0，1，2；log.dirs必须保证目录存在，不会根据配置文件自动生成； 最后，启动三台机器的zookeeper ， 然后启动三台机器的kafka 1bin/kafka-server-start.sh config/server.properties &amp; 三个节点均要启动；启动无报错，即搭建成功，可以生产和消费消息，来检测是否搭建成功。 至此，kafka集群环境搭建完毕，下面写一些java中如何使用 java环境kafka测试生产者和消费者 导入包 123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.12&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-streams&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 消费者 https://kafka.apache.org/10/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Arrays;import java.util.Properties;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;/** * 消费者 * * 测试体验， kafka的消费能力真的很快 * * @author LELE * */public class KafkaConsu extends KafkaConsumer &#123; public KafkaConsu(Properties properties) &#123; super(properties); // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; Properties props = new Properties(); // kafka servers props.put("bootstrap.servers", "192.168.175.130:9092,192.168.175.131:9092,192.168.175.132:9092"); // group props.put("group.id", "DemoConsumer"); props.put("enable.auto.commit", "true"); props.put("auto.commit.interval.ms", "1000"); props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props); // 订阅的topic consumer.subscribe(Arrays.asList("my-topic")); while (true) &#123; // 超时时间 ms ConsumerRecords&lt;String, String&gt; records = consumer.poll(100); for (ConsumerRecord&lt;String, String&gt; record : records) System.out.printf("测试 offset = %d, key = %s, value = %s%n", record.offset(), record.key(), record.value()); &#125; &#125;&#125; kafka生产者 https://kafka.apache.org/10/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Properties;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.Producer;import org.apache.kafka.clients.producer.ProducerRecord;/** * 消息生产者 * @author LELE * */public class KafkaProdu extends KafkaProducer &#123; public KafkaProdu(Properties properties) &#123; super(properties); &#125; public static void main(String[] args) throws Exception &#123; Properties props = new Properties(); // kafka servers props.put("bootstrap.servers", "192.168.175.130:9092,192.168.175.131:9092,192.168.175.132:9092"); props.put("acks", "all"); props.put("retries", 0); props.put("batch.size", 16384); props.put("linger.ms", 1); // topic 分组 props.put("client.id", "DemoProducer"); props.put("buffer.memory", 33554432); // 序列化工具 props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer"); // 序列化工具 props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer"); Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); for (int i = 0; i &lt; 1000000; i++) producer.send(new ProducerRecord&lt;String, String&gt;("my-topic", Integer.toString(i), Integer.toString(i))); producer.close(); &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js常用小案例]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2Fjs%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[常用javascript小案例 样式调节 123456//注: 这个可以控制td中的字段成行显示 #modelInfos td,th &#123; white-space: nowrap; &#125;//文本输入框随着内容尺寸往下变大,在input框中加入这两个属性,然后就可以控制文本输入框的大小尺寸随着内容而变onpropertychange="this.style.height=this.scrollHeight + 'px'" oninput="this.style.height=this.scrollHeight + 'px'" 点击radio 选择一整行(这种写法不太靠谱，可以试试) 1234567891011121314151617181920style="cursor: hand" bgcolor="&lt;%=(obj.getState() == 0 ? trColor : obj.getState() == 1 ? '#FFCC33' : '#FF8040')%&gt;" onclick="selectRow(&lt;%=i%&gt;,this);"// 注: 另一种写法 双击选中一行[单击不可以$(function()&#123; var screenSize = window.screen.width-200; var div1 = document.getElementById('pool'); div1.style.width = screenSize; $('tr').dblclick(function()&#123; $td = $(this).find("td:eq(0)").find("input[type=radio]").attr("checked", true); var varId = $(this).attr("id"); if($(this).attr("id").length&gt;3)&#123; var str = varId.substr(0,3); if(str=='row')&#123; startDealTask(); &#125; &#125; return false; &#125;);&#125;) 当前条件所在的行的颜色为红色 123456 $("tr",$("#gxzItems")).each(function()&#123; var itemFlag=$("input[name='flagTY']",$(this)).val(); if(itemFlag=='0')&#123; $("td", $(this)).css(&#123;"color":"red"&#125;); &#125;&#125;); 格式化金额 1&lt;fmt:formatNumber pattern="#,##0.00#" value="$&#123;pto1.map.tradeAmt&#125;" /&gt; 写弹窗(标题div中需要加入的样式) 1style="display: none; z-index: 9997; border-width: 1px; border-style: solid; border-color: navy; position: absolute; left: 250px; top: 103px; background-color: #ffffff; width: 350px; height: 115px; filter: progid :DXImageTransform.Microsoft.Shadow(color =#999999, direction =135, strength = 5);" 支持拖拽 12345678910111213141516171819202122232425262728293031oTitle.onmousedown=function(event)&#123; oTitle.style.cursor = "move"; var event = event || window.event; var disX=event.clientX-oDrag.offsetLeft; var disY=event.clientY-oDrag.offsetTop; // 鼠标移动，窗口随之移动, onmousemove在有物体移动是才执行alert事件； document.onmousemove=function(event)&#123; var event = event || window.event; maxW=document.documentElement.clientWidth-oDrag.offsetWidth; maxH=document.documentElement.clientHeight-oDrag.offsetHeight; posX=event.clientX-disX; posY=event.clientY-disY; if(posX&lt;0)&#123; posX=0; &#125;else if(posX&gt;maxW)&#123; posX=maxW; &#125; if(posY&lt;0)&#123; posY=0; &#125;else if(posY&gt;maxH)&#123; posY=maxH; &#125; oDrag.style.left=posX+'px'; oDrag.style.top=posY+'px'; &#125; //鼠标松开，窗口将不再移动 , document.onmouseup=function()&#123; document.onmousemove=null; document.onmouseup=null; &#125; &#125; 测试用户点击关闭浏览器,事件回到数据库中执行一条语句 123456789101112131415161718&lt;script type="text/javascript" src="&lt;c:url value='/js/jquery-1.8.3.js'/&gt;"&gt;&lt;/script&gt;&lt;script&gt; window.onbeforeunload = function() //author: meizz &#123; var n = window.event.screenX - window.screenLeft; var b = n &gt; document.documentElement.scrollWidth - 20; if (b &amp;&amp; window.event.clientY &lt; 0 || window.event.altKey) &#123; $.ajax(&#123; url : "/demo03/itemModel/onbeforeload", async : false, success : function() &#123; alert("不可能"); &#125; &#125;); &#125; &#125;&lt;/script&gt; 提交点击提交form表单值, 则可以将结果显示在当前页面的iframe内联框中, 实现页面局部刷新 123456789&lt;form id="organManageForm" name="organManageForm" style="width: 30%" action="&lt;%=com.northking.ssoClient.bussiness.impl.Parameters.pathPrefix%&gt;servlet/SmOrganListServlet" method="post" target="frmdetail"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/td&gt; &lt;td width="50%" style="vertical-align: top"&gt; &lt;div id="floater" style="position:absolute; height=300"&gt; &lt;iframe name="frmdetail" class="" frameborder=0 style="width: 100%;height:100%;background-color: #eeeeee;"&gt;&lt;/iframe&gt; &lt;/div&gt; 图片响应流到页面展示, filepath = &quot;“图片路径”; 1234567891011121314151617response.setContentType("image/jpeg");ServletOutputStream out=response.getOutputStream(); try &#123; File file = new File(filePath); FileImageInputStream imageinput = new FileImageInputStream(file); int data; while((data=imageinput.read())!=-1) &#123; out.write(data); &#125; imageinput.close(); &#125; catch (Exception e) &#123; logger.error(e); &#125;finally&#123; out.flush(); out.close(); &#125; 使用js写COOKIE 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type="text/javascript"&gt;function getCookie(c_name)&#123;if (document.cookie.length&gt;0) &#123; c_start=document.cookie.indexOf(c_name + "=") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(";",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125;return ""&#125;function setCookie(c_name,value,expiredays)&#123;var exdate=new Date()exdate.setDate(exdate.getDate()+expiredays)document.cookie=c_name+ "=" +escape(value)+((expiredays==null) ? "" : ";expires="+exdate.toGMTString())&#125;function checkCookie()&#123;username=getCookie('username')if (username!=null &amp;&amp; username!="") &#123;alert('Welcome again '+username+'!')&#125;else &#123; username=prompt('Please enter your name:',"") if (username!=null &amp;&amp; username!="") &#123; setCookie('username',username,365) &#125; &#125;&#125;&lt;/script&gt;&lt;body onLoad="checkCookie()"&gt; 常知小技巧 对于任何类型的值采用双not ,可以得到其真正的boolean类型值 . 写法: if(!!cont){} [注: 有值就表示true , 没值或为false或为0就返回false] null 与 undefined 是相等的 if(null == undefined) { 返回true } , [注: 非全等号由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。] start : i = 5; 可以以这样的方式给语句加个标签, 方面下面调用. js中文转码: encodeURI(encodeURI( //需要转码的内容 )) 要想实现点击下拉框, 选中内容在文本框中显示, 并且支持多选 , 请百度搜索 multiple-select 使用这种函数 var formData=$(“form”).serialize(); ,可以获取form表单中的参数和值, 以 name=2&amp;pass=3的 形式连接到一块 arguments[0] .length 这些可以写在函数内部, arguments是系统命名的获取传进函数的变量的值的数组集合 , 可以不用声明,直接在函数内部使用,而只需要调用是传参数就行 1234567891011121314151617181920212223242526&lt;a href="javascript:void(0);" onclick="sayHi('',null,undefined)"&gt;点击这里,调用函数&lt;/a&gt;&lt;/body&gt;&lt;script tyee="text/javascript"&gt; function sayHi() &#123; var num=arguments.length; if (num != 0) &#123;//调用传参函数 if(num==1)&#123;//调用传一个参函数 alert("1个参数"); &#125;else if(num==2)&#123;//调用传2个参函数 alert("2个参数"); &#125;else if(num==3)&#123;//调用传3个参函数 alert("3个参数"); &#125;else&#123;//调用传其他参函数 alert("3个以上参数"); &#125; &#125;else &#123;//调用无参函数 alert("你没有往该函数里面传入任何值!!!"); &#125;&#125;// 注： 可以使用函数名.length, 来获取该函数传入参数的个数.&lt;/script&gt; 在函数中使用闭包 , 内部函数不能传参, 但可以使用外部的一切变量. 1234567var iBaseNum = 10;function addNum(iNum1, iNum2) &#123; function doAdd() &#123; return iNum1 + iNum2 + iBaseNum; &#125; return doAdd();&#125; 图像操作. (详细请看附加图像文件) ( ) 1234567891011// 图像 旋转 的函数var irotation = 1;function rotation()&#123; document.all.IFramePic1.style.filter ="progid:DXImageTransform.Microsoft.BasicImage(rotation="+ irotation +")"; irotation++; if(irotation&gt;4) &#123; irotation=1; &#125;&#125; 使用js获取上月最后一天日期 12345678910111213141516171819202122232425262728293031323334353637&lt;script type="text/javascript"&gt; $(function()&#123; var endAccountDate = document.getElementById("endAccountDate").value; if(endAccountDate==null||endAccountDate=='')&#123; var nowdays = new Date(); var year = nowdays.getFullYear(); var month = nowdays.getMonth(); if(month==0) &#123; month=12; year=year-1; &#125; if (month &lt; 10) &#123; month = "0" + month; &#125; var firstDay = year + "-" + month + "-" + "01";//上个月的第一天 var myDate = new Date(year, month, 0); var lastDay = year + "-" + month + "-" + myDate.getDate();//上个月的最后一天 &#125; &#125;);function Appendzero(obj) &#123; if(obj&lt;10) return "0" +""+ obj; else return obj; &#125;function resolveDayDate(begin_Date,end_Date)&#123; var beginDate = new Date(begin_Date.substring(0,4),begin_Date.substring(4,6)-1,begin_Date.substring(6,8)); var endDate = new Date(end_Date.substring(0,4),end_Date.substring(4,6)-1,end_Date.substring(6,8)); beginDate.setDate(beginDate.getDate()+31); return beginDate.getTime() &gt;= endDate.getTime();&#125; function resolveMonthDate(begin_Date,end_Date)&#123; var beginDate = new Date(begin_Date.substring(0,4),begin_Date.substring(4,6)-1,begin_Date.substring(6,8)); var endDate = new Date(end_Date.substring(0,4),end_Date.substring(4,6)-1,end_Date.substring(6,8)); beginDate.setMonth(beginDate.getMonth()+12); return beginDate.getTime() &gt;= endDate.getTime();&#125; &lt;/script&gt; 获取当前日期上月最后一天 123456789101112131415161718192021222324 $(function()&#123; var fl=$("#fl").val(); if(fl=='0')&#123; var endDate=$("input[name='endAccountDate']").val(); var ss=ff(endDate); $("input[name='startAccountDate']").val(ss); &#125; &#125;);function ff(endDate)&#123; var month = endDate.substr(4,2); var year = endDate.substr(0,4); if(month=='01')&#123; month = 12; year -=1; &#125;else&#123; month -=1; &#125; var day = new Date(year, month, 0).getDate(); return year+""+Appendzero(month)+""+Appendzero(day);&#125;function Appendzero(obj) &#123; if(obj&lt;10) return "0" +""+ obj; else return obj; &#125; 内容相对于滚动条位置不动 12345678$(function()&#123; var screenSize = window.screen.width-200; var div1 = document.getElementById('pool'); div1.style.width = screenSize; &#125;);&lt;div id="pool" style="overflow: auto;"&gt; //要优化的内容&lt;/div&gt; 悬浮动态走马灯 123&lt;marquee style="WIDTH: 100%; HEIGHT: 400px" scrollamount="3" direction="up"&gt; &lt;span style="color: red; font-size: 20px;"&gt;&lt;strong&gt;页面维护中..&lt;/strong&gt;&lt;/span&gt;&lt;/marquee&gt; 下拉框多选[select] , 在下拉框中添加 multiple=“multiple” 属性 123456789// js代码function subbmit()&#123; var all = ""; $("select[name='orgId'] option").each(function() &#123; all += $(this).attr("value")+" "; &#125;); var sel = $("select[name='orgId']").val(); alert("多选列表所有的值是: " + all + "其中被选中的是"+sel+"。); &#125; 使用javascript操作excel 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; New Document &lt;/title&gt; &lt;meta name="Generator" content="EditPlus"&gt; &lt;meta name="Author" content=""&gt; &lt;meta name="Keywords" content=""&gt; &lt;meta name="Description" content=""&gt; &lt;script type="text/javascript"&gt; var array1 = []; var arr; function WriteExcel() &#123; var tempStr = ""; //得到文件路径的值 var filePath = document.getElementById("upfile").value; //创建操作EXCEL应用程序的实例 try &#123; var oXL = new ActiveXObject("Excel.application"); &#125; catch(e) &#123; alert("请启用ActiveX控件设置！"); return; &#125; //打开指定路径的excel文件 var oWB = oXL.Workbooks.open(filePath); //操作第一个sheet(从一开始，而非零) oWB.worksheets(1).select(); var oSheet = oWB.ActiveSheet; //使用的行数 var rows = oSheet.usedrange.rows.count; try &#123; for (var i = 1; i &lt;= rows; i++) &#123; var obj = new Object(); obj.seq = oSheet.Cells(i,1).value; obj.jgmc= oSheet.Cells(i,2).value; obj.wdmc= oSheet.Cells(i,3).value; obj.wddm= oSheet.Cells(i,4).value; obj.ywpz= oSheet.Cells(i,5).value; obj.hdmx= oSheet.Cells(i,6).value; obj.cccy= oSheet.Cells(i,7).value; obj.cccyfb= oSheet.Cells(i,8).value; obj.sjkm= oSheet.Cells(i,9).value; obj.cclx= oSheet.Cells(i,10).value; obj.cccjrq= oSheet.Cells(i,11).value; obj.ywrq= oSheet.Cells(i,12).value; obj.ccy= oSheet.Cells(i,13).value; obj.sjje= oSheet.Cells(i,14).value; array1.push(obj); obj=null; &#125; arr = JSON.stringify(array1); &#125; catch(e) &#123; document.getElementById("txtArea").value = "出错了"; &#125; document.getElementById("txtArea").value = arr; //退出操作excel的实例对象 oXL.Application.Quit(); //手动调用垃圾收集器 CollectGarbage(); &#125; function ReadExcel()&#123; alert(array1[1].jgmc); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="file" id="upfile" /&gt; &lt;input type="button" onclick="WriteExcel();" value="write"&gt; &lt;input type="button" onclick="ReadExcel();" value="read"&gt; &lt;br&gt; &lt;textarea id="txtArea" cols=200 rows=400&gt; &lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; 未完待续， 后续补充中。。。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 主题介绍]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2Fhexo%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Hexo 小插曲介绍 虽然标题是第一次写博客、 但是我这个困难户至少挣扎了1年多了， 一直下不去手、今天可算是开了个头、 贵在坚持吧 抽时间介绍我的hexo安装历程吧，今天实在是有点困了，要睡觉了。 昨天竟然通宵了、 搞到早上6点多，快7点才去睡觉、 今天上午睡了一上午，下午才醒， 哎，果然还是上班轻松，不上班的时候是真的累， 玩了几个小时，现在该正正经经的写下介绍了 Hexo 准备开始 准备环境 Node.js官网下载最新的安装包 https://nodejs.org/en/ 、 安装完后、cmd检查下是否安装成功。 Git官网下载最新安装包 https://git-scm.com/ 、 同样安装完后，鼠标右键看下是否又 安装Hexo , 在需要新建工程的目录下， 鼠标右键（即git bash）依次运行一下命令： 1npm install -g hexo-cli 初始化Hexo命令后， 在命令行（即git bash）依次运行下面命令: 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成后， 会在你的工程目类下，产生如下文件夹和文件： 12345678.├── _config.yml #站点目类配置文件├── package.json├── scaffolds├── source #mkdown博文书写目类| ├── _drafts| └── _posts└── themes #加载或引入主题 启动服务器， （git bash）命令窗口输入 1hexo server 注： 有可能上面一行命令会报错，报hexo不是命令或common base error: hexo not found 。。之类的 这里有一种解决方案： 在你使用第三步安装hexo客户端时， 仔细看输出内容里面有个路径，例如 12将如下自己电脑中的hexo路径配置在path环境变量中，即可解决hexo命令找不到问题C:\Users\...\AppData\Roaming\npm\node_modules\hexo-cli\bin\ 浏览器中访问地址： http://localhost:4000/ 至此、 您的hexo 博客已经在本地搭建好了， 快去运行看看吧！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/supenman_mwg/article/details/39000037]]></content>
      <categories>
        <category>技术博客</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aes加解密应用]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8A%80%E6%9C%AF%2Faes%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用AES加密解密代码详解 首先，如果是使用nodejs + vue 写的前端， 那么你需要npm 加载一个js文件 12npm i crypto-js --save --save-exactnpm install crypto-js java代码加密解密类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.telling.util.crypto;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.binary.Base64;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class Aes &#123; private static final Log logger = LogFactory.getLog(Aes.class); // log日志 private static final String ALGORITHM = "AES/ECB/PKCS5Padding"; // "算法/模式/补码方式" /***************************************************** * AES加密 * * @param content * 加密内容 * @param key * 加密密码，由字母或数字组成 此方法使用AES-128-ECB加密模式，key需要为16位 * 加密解密key必须相同，如：abcd1234abcd1234 * @return 加密密文 ****************************************************/ public static String enCode(String content, String key) &#123; if (key == null || "".equals(key)) &#123; logger.info("key为空！"); return null; &#125; if (key.length() != 16) &#123; logger.info("key长度不是16位！"); return null; &#125; try &#123; byte[] raw = key.getBytes(); // 获得密码的字节数组 SecretKeySpec skey = new SecretKeySpec(raw, "AES"); // 根据密码生成AES密钥 Cipher cipher = Cipher.getInstance(ALGORITHM); // 根据指定算法ALGORITHM自成密码器 cipher.init(Cipher.ENCRYPT_MODE, skey); // 初始化密码器，第一个参数为加密(ENCRYPT_MODE)或者解密(DECRYPT_MODE)操作，第二个参数为生成的AES密钥 byte[] byte_content = content.getBytes("utf-8"); // 获取加密内容的字节数组(设置为utf-8)不然内容中如果有中文和英文混合中文就会解密为乱码 byte[] encode_content = cipher.doFinal(byte_content); // 密码器加密数据 return Base64.encodeBase64String(encode_content); // 将加密后的数据转换为字符串返回 &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /***************************************************** * AES解密 * * @param content * 加密密文 * @param key * 加密密码,由字母或数字组成 此方法使用AES-128-ECB加密模式，key需要为16位 加密解密key必须相同 * @return 解密明文 ****************************************************/ public static String deCode(String content, String key) &#123; if (key == null || "".equals(key)) &#123; logger.info("key为空！"); return null; &#125; if (key.length() != 16) &#123; logger.info("key长度不是16位！"); return null; &#125; try &#123; byte[] raw = key.getBytes(); // 获得密码的字节数组 SecretKeySpec skey = new SecretKeySpec(raw, "AES"); // 根据密码生成AES密钥 Cipher cipher = Cipher.getInstance(ALGORITHM); // 根据指定算法ALGORITHM自成密码器 cipher.init(Cipher.DECRYPT_MODE, skey); // 初始化密码器，第一个参数为加密(ENCRYPT_MODE)或者解密(DECRYPT_MODE)操作，第二个参数为生成的AES密钥 byte[] encode_content = Base64.decodeBase64(content); // 把密文字符串转回密文字节数组 byte[] byte_content = cipher.doFinal(encode_content); // 密码器解密数据 return new String(byte_content, "utf-8"); // 将解密后的数据转换为字符串返回 &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /***************************************************** * AES加密解密测试 * * @param args * @return ****************************************************/ public static void main(String[] args) &#123; String content = "加密解密测试"; logger.info("加密content：" + content); String key = "abcd1234abcd1234"; logger.info("加密key：" + key); String enResult = enCode(content, key); logger.info("加密result：" + enResult); String deResult = deCode(enResult, key); logger.info("解密result：" + deResult); &#125;&#125; java类中加密解密使用方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@ResponseBody @RequestMapping("/getqingHou") public String getqingHou(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; try &#123; Map map = this.getParameterMap(request); Map retuData = new HashMap&lt;&gt;(16); map.put("role", "admin"); /*****************前端传过来的加密值，进行解密*********************************************************/ String keyC = map.get("keyC").toString(); String contC = map.get("contentC").toString(); System.out.println(keyC + " : " + contC); String decC = new String(Aes.deCode(contC, keyC)); System.out.println("前端传进来的数据： 解密后----》》》 " + decC); System.out.println("------------------------------------------------------------------"); /**************************加密字符串，解密字符串****************************************************/ // 1234567890ABCDEF1234567890ABCDEf String key = UUID.randomUUID().toString().replace("-", "").toUpperCase().toString().substring(0,14) + "=="; String src = "Ejian111234"; System.out.println("key----&gt;&gt;&gt;&gt; "+key); // 加密字符串 String enc = Aes.enCode(src, key); System.out.println("加密后---》》》 " + enc); // 解密后 String dec = new String(Aes.deCode(enc, key)); System.out.println("解密后----》》》 " + dec); System.out.println("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"); /***************************加密数组，传到前端进行解密***************************************************/ String mapEnc = Aes.enCode(JSON.toJSONString(map), key); System.out.println("集合类型加密后的数据： " + mapEnc); retuData.put("enc", enc); retuData.put("key", key); retuData.put("map", mapEnc); logger.info("+++++++get user info !" + retuData); return JSON.toJSONString(retuData); &#125; catch (LoginException e) &#123; logger.error(e.getMessage()); return e.getErrorCode() + "_" + e.getMessage(); &#125; &#125; js代码加密解密方法 123456789101112131415161718192021222324252627282930const CryptoJS = require("crypto-js")/***************************************************** * AES加密 * @param content 加密内容 * @param key 加密密码，由字母或数字组成 此方法使用AES-128-ECB加密模式，key需要为16位 加密解密key必须相同，如：abcd1234abcd1234 * @return 加密密文 ****************************************************/export function encrypt(content, key) &#123; const sKey = CryptoJS.enc.Utf8.parse(key); const sContent = CryptoJS.enc.Utf8.parse(content); const encrypted = CryptoJS.AES.encrypt(sContent, sKey, &#123;mode:CryptoJS.mode.ECB,padding: CryptoJS.pad.Pkcs7&#125;); return encrypted.toString();&#125;/***************************************************** * AES解密 * @param content 加密密文 * @param key 加密密码，由字母或数字组成 此方法使用AES-128-ECB加密模式，key需要为16位 加密解密key必须相同，如：abcd1234abcd1234 * @return 解密明文 ****************************************************/export function decrypt(content, key) &#123; const sKey = CryptoJS.enc.Utf8.parse(key); const decrypt = CryptoJS.AES.decrypt(content, sKey, &#123;mode:CryptoJS.mode.ECB,padding: CryptoJS.pad.Pkcs7&#125;); return CryptoJS.enc.Utf8.stringify(decrypt).toString();&#125; 前端加密解密使用方法 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; import &#123; getqingHou &#125; from "api/test.js"; import &#123; decrypt, encrypt &#125; from "api/cryptoAes.js" var CryptoJS = require("crypto-js") export default &#123; name: "login", created() &#123; this.getqingHouFun() &#125;, methods: &#123; getqingHouFun() &#123; console.log('============test===start===========') getqingHou(&#123;test: 'test', keyC: '1234567890ABCDEF', contentC: encrypt('Ejian111234567890', '1234567890ABCDEF')&#125;).then(response =&gt; &#123; console.log(response.data) console.log('=====================aes===================') // npm i crypto-js --save --save-exact // npm install crypto-js var decrypt1 = decrypt(response.data.enc, response.data.key); console.log("后端解密后的数据: ---字符串类型&gt;&gt;&gt; " + decrypt1) var decrypt2 = decrypt(response.data.map, response.data.key); console.log("后端解密后的数据：---集合类型&gt;&gt;&gt; " + decrypt2) var json = JSON.parse(decrypt2); console.log("后端解密后的数据：---集合类型&gt;&gt;&gt;------转JSON&gt;&gt;&gt; " + json.contentC) console.log('===========test===end===================') &#125;) &#125; &#125; &#125;&lt;/script&gt; 好了，代码全部贴出来了， 直接copy就能用， 记得看过点赞， 发个言在走哦！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过往4年]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%84%9F%E6%82%9F%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94(%E6%A0%87%E9%A2%98%E8%8A%82%E7%82%B9%E8%8C%83%E6%96%87)%2F</url>
    <content type="text"><![CDATA[请您输入管理员授权密码、点击解码键（Decrypt）继续阅读该文章！ Decrypt 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]]></content>
      <categories>
        <category>生活唠嗑</category>
      </categories>
      <tags>
        <tag>生活琐事碎碎念</tag>
        <tag>生活随笔</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔生活]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%84%9F%E6%82%9F%2F%E7%94%9F%E6%B4%BB%E5%B0%8F%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[请您输入管理员授权密码、点击解码键（Decrypt）继续阅读该文章！ Decrypt U2FsdGVkX1/E6okoxy5KuG6EjfZlaiIl48aqQ/cdwrAzrB4C577zmFuns5tf/m2pWlzPwr+G73ATY70qYcHrhHcakzyKyHLsPJTrATsJfJLnyMTqfy1rMTz3c1WZd8HO29yQSgChZ4UR6K940wreKaaZ5U2KCTSVFXoAgTyyXWqfKHKOHl4M2TR61KtnxSxXBJBalfDLTtqnf8iu2nsmXz9hzSHnk5RLlVFxafdVusZFs3vbAhE5FeFGBHgfZXA3lMeHWCB2L98MpvZShRha3DRpn3xGoFpMl+oMIg9x+U66NzpEdNbxGb7Z0e0QXK5m2nPLRhQFyD8t/yus5rhLydMS8sa7U9SKsMka/FGHPtkMIizxvmhcyUi85vqz0fJ6iBkcMK6O5F+lny9Ur8tSUqbVdVara6hIeheo3n/2k8e+pOGB2IFh5Fuvaq4MEORrwhnJ3AMg6IYzonoQ/Lnufw95HJC0R9Fy5syeY/EvzuspdDTgoAb+24IMrsZLunX6c/FQOlJXBoH2/yiaaqMCewA1gePw4COZ+zY1xygJ8Qiu2phR8eSsbdyXT5Z4snQmxo2q5FD+3MIeUnZKiSf7AHLcPpzjLDf6VX1MnGeL4C6vHVMw/tArdDffxvgXYMTb2IzTjWV6KxOQDlVGuXIAiQSKk/yvK4iK7sf6LxP94hmc3QJJw9bwAOF+J/Yav2B/xmT7CvPGepigP7dVMzlOyLUBkSLwt9L+C+Rx2aW6MrgWQCXvlJY/zfc1puw6fMX9AxZTlx8E9HpvNzYh8rZqDfkWR/p30szjfTI5ZxgFeqwC8pUQOSM5o++7OPwiGC0QuQzKNV8MsHxNRvRNf2//Fe7I3xUFtZRMrF6qcJOsGG6PXKDxII1Xcxybm8OGUxaTSy/mzSmNRUASMLyJEpkss9pIVuB9JCRLSnC0hUzBfT+GBqVa7EpTdgatakWSyhIAkxzC3VM4JL5OtXjzEi4PGl1FEqE5rb9pu/c8eUUigjdNMBP3BYHet+yJoTvY6oWWeRlRyqfik0JQ+x0dE/osSQx8vHLQHJ0Lfk607foK9mRyI9EfqL6JsKe1a17p8FsJaQKe6Qf3sKXserxGgd5PkrPRqcn0jBBs//q1W668/TmGNyiOpds6vrejCjG75XkPQbTT0g09USr8kU2X6KhQeDte4Zjl8kuYZCkqvLEqvJ9SVCeiQ52FTAzboHQFwbZ7x+udYK5S9xnJuXs6/y6jZd8Ia1MdxD4xQGcViQKdkVAMXPKES4Hb0cXSoZpwXgofqBS/LTbisoUnfj5SuI8wrbi8ZAFRaXSzyBZp04OOdMW/y8e9/G4j7BJU8HAhW1tUb/9PiUvz1mApfRESf2qqab9oIHJfBrGwkDOidoy/l38=]]></content>
      <categories>
        <category>生活唠嗑</category>
      </categories>
      <tags>
        <tag>生活琐事碎碎念</tag>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鸡汤]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%84%9F%E6%82%9F%2F%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[鸡汤 路很长、 请适当放慢脚步、不要错过路边的风景 不懂得拒绝别人的请求 太容易暴露自己的内心♥ 应得的利益不知道去争取 没有底线与原则的宽容 没事少装B、现实会啪啪打脸的 面子是别人给的、脸是自己挣得 脸皮厚点、不开心也不要直接表现出来、经常笑着，不要老是板着张脸 遇到领导、遇到能力比你强的、而且平时表现又很强势的、 不要怂、 你他妈是谁啊、 大不了老子不干了、 别他妈瞎吵吵]]></content>
      <categories>
        <category>人生哲理</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有毒的代码注释]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%B7%A5%E5%85%B7%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[有毒的代码注释 鸟 123456789101112131415161718192021222324252627/* .---. .-----------* / \ __ / ------* / / \( )/ -----* ////// ' \/ ` ---* //// / // : : ---* // / / /` '--* // //..\\* ====UU====UU====* '//||\\`* ''``*/ /** .-'-._* / e&lt;* _.-'''; (* _______.-''-._.-' /* ====---:_''-' / _ _ %%%%* '-=. .-'` _(_)(_) %%|/%%%* _|_\_ (_)(_)(_) %%%%%%%%%%* //\\//\\//\\//\\//\\%/_%%%%%%%* ____\\//\\//\\//\\//\\// |__|/__%%%* ________(___ \\/\//\\//\\//\\//__//___%%%%%%%* / \ \_/ __ \___//------\--%%%%%%* _________/ \____/ \____/\\%%%%%%%%%%%%* \_-%%%%%%%%**/ 简易计算器 12345678910111213141516171819202122/** +---------------------------+* | ///////////////////////// |* +---------------------------+* | [ 1,264.45 ] |* +---------------------------+* | |* | |* | [sto] [rcl] [&lt;--] [AC/ON] |* | |* | [ ( ] [ ) ] [sqr] [ / ] |* | |* | [ 7 ] [ 8 ] [ 9 ] [ * ] |* | |* | [ 4 ] [ 5 ] [ 6 ] [ - ] |* | |* | [ 1 ] [ 2 ] [ 3 ] [ + ] |* | |* | [ 0 ] [ . ] [+/-] [ = ] |* | |* +---------------------------+*/ hello kitty 可爱的小猫咪 12345678910111213141516171819202122232425262728293031323334353637/** !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!` `4!!!!!!!!!!~4!!!!!!!!!!!!!!!!!* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &lt;~: ~!!!~ .. 4!!!!!!!!!!!!!!!* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ~~~~~~~ ' ud$$$$$ !!!!!!!!!!!!!!!* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ~~~~~~~~~: ?$$$$$$$$$ !!!!!!!!!!!!!!* !!!!!!!!!!!` ``~!!!!!!!!!!!!!! ~~~~~ "*$$$$$k `!!!!!!!!!!!!!* !!!!!!!!!! $$$$$bu. '~!~` . '~~~~ :~~~~ `4!!!!!!!!!!!* !!!!!!!!! $$$$$$$$$$$c .zW$$$$$E ~~~~ ~~~~~~~~ ~~~~~: '!!!!!!!!!!* !!!!!!!!! d$$$$$$$$$$$$$$$$$$$$$$E ~~~~~ '~~~~~~~~ ~~~~~ !!!!!!!!!!* !!!!!!!!&gt; 9$$$$$$$$$$$$$$$$$$$$$$$ '~~~~~~~ '~~~~~~~~ ~~~~ !!!!!!!!!!* !!!!!!!!&gt; $$$$$$$$$$$$$$$$$$$$$$$$b ~~~ '~~~~~~~ '~~~ '!!!!!!!!!!* !!!!!!!!&gt; $$$$$$$$$$$$$$$$$$$$$$$$$$$cuuue$$N. ~ ~~~ !!!!!!!!!!!* !!!!!!!!! **$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$Ne ~~~~~~~~ `!!!!!!!!!!!* !!!!!!!!! J$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$N ~~~~~ zL '!!!!!!!!!!* !!!!!!!! d$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$c z$$$c `!!!!!!!!!* !!!!!!!&gt; &lt;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&gt; 4!!!!!!!!* !!!!!!! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ !!!!!!!!* !!!!!!! &lt;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*" ....:!!* !!!!!!~ 9$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$e@$N '!!!!!!!* !!!!!! 9$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ !!!!!!!* !!!!!! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$""$$$$$$$$$$$~ ~~4!!!!* !!!!!! 9$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$Lue :::!!!!* !!!!!!&gt; 9$$$$$$$$$$$$" '$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$ !!!!!!!* !!!!!!! '$$*$$$$$$$$E '$$$$$$$$$$$$$$$$$$$$$$$$$$$u.@$$$$$$$$$E '!!!!!!!* !!!!~` .eeW$$$$$$$$ :$$$$$$$$$$$$$***$$$$$$$$$$$$$$$$$$$$u. `~!!!!!* !!&gt; .:!h '$$$$$$$$$$$$ed$$$$$$$$$$$$Fz$$b $$$$$$$$$$$$$$$$$$$$$F '!h. !!!* !!!!!!!!L '$**$$$$$$$$$$$$$$$$$$$$$$ *$$$ $$$$$$$$$$$$$$$$$$$$F !!!!!!!!!* !!!!!!!!! d$$$$$$$$$$$$$$$$$$$$$$$$buud$$$$$$$$$$$$$$$$$$$$" !!!!!!!!!!* !!!!!!! .&lt;! #$$*"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$* :!!!!!!!!!!!* !!!!!!!!!!!!: d$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$# :!!!!!!!!!!!!!* !!!!!!!!!!!~ : '#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*" !!!!!!!!!!!!!!!* !!!!!!!!!! !!!!!: ^"**$$$$$$$$$$$$$$$$$$$$**#" .:&lt;!!!!!!!!!!!!!!!!!* !!!!!!!!!!!!!!!!!!!!!:... .::!!!!!!!!!!!!!!!!!!!!!!!!* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!**/ happy happy 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** .,,. .,,.*:XXXX,XXXX: .SSSSSSS'*'XXXXXXXXX' .SSSSSSSS,WW:, .''':,.* ':XXXXX:' .SSSSSSSSSS:WWW:, '::,* 'XXX' .SSSSSSSSS,WWW( )WW '::, '////* ':' SSSSSSSSSSSS'WWWWWWD '::,////* ,. SSSSSSS(((SSSWWWWW ,WW//:.'.W.* ,((() 'SSSSSS(((WWWWWWWWWW) //'W,:WWWW'* ,(((((() 'SSSSSS((WWWWWWWWWW) // 'WWW,WWW* .,(((((((()) 'SSSSWWWWWWWWWWW' // .WWWWW:,* .,((((((((((())), SSWWWWWWWWWW' // ,WWWW' ':,* .,((((((((((((((())))),.,,,,WWWWWWWWWW:, // ,WWWWW' ':*'((((((((((((((((((((()))))WWWWWWWWWWWWWVVVV//WWWWW:,.,WWWWW' :* ((((((((((((((((((()))(WWWWWWWWWWWWWWVVVVVVWWWWWWWWWWWWW' '* ((((((((((((((((()))(WWWWWWWWWWWWWVVVVVVVWWWWWWWWWWWW'* (((((((((((((())(()(WWWWWWWWW.VVVVVVVWWWWWWWWWWW:'* ((((((((())) ()(WWWWWW.VVVVVVV'WWWWWWW'' .,,. .,,.* ((((())) ((WW,VVVVVVVVV'WWWWWWWWW :XXXX,XXXX:* WVVVVVVVVVV'WWWWWWWW:' 'XXXXXXXXX'* .,,. .,,. VVVVVVVVV'WWWWWWWWWW ':XXXXX:'* :XXXX,XXXX: .WVVVVVVV'WWWWWWWWWWWW 'XXX'* 'XXXXXXXXX' .WWW''''',WWWWWWWWWWWW: ':'* ':XXXXX:' (())))WWWWWWWWWWWWWWWWW'* 'XXX' ((())))))WWWWWWWWWWWWWW'* ':' ((()))))))))WWWWWWWWWWW'* ()WWWWWW))))))))))))))))* :WWWWWWWWW)))))))))))))) .,,. .,,.* WWWWWWWWWWW)))))))WWWWW. :XXXX,XXXX:* :WWWWWWWWWW')))))WWWWWWWW. 'XXXXXXXXX'* WWWWWWWWWW' 'WWWWWWWWWWWW ':XXXXX:'* .,,:WWWW:,WWWWWWWWW' 'WWWWWWWWWWW 'XXX'* ,WWWWWWWWWWWWWWWWWW' 'WWWWWWWWW ':'* ,WWWWWWWWWWWWWWWWWW' 'WWWWWWWW,* WWWWWWW' '':WWW:' 'WWWWWWWW* .WWWWWWW' .WWWWWWWWW* ''W'W'WW ,WWWWWWWWW' .,,. .,,.* '' ,WWWWWWWW' :XXXX,XXXX:* .,,. .,,. .WWWWWW:' 'XXXXXXXXX'* :XXXX,XXXX: .WWWWWWW' ':XXXXX:'* 'XXXXXXXXX' WWWWWW' 'XXX'* ':XXXXX:' WWWWW' ':'* 'XXX' WWWW.* ':' 'WWWWW,* '' ''*/ 小情侣 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** ,m##mmmmm.* ,d###########m.* ,d###############b* ,d##################b* 'd###################b,* ;#####################* d#######"+Y#b~~####### _mmm,mmm._* #######( ||#P #P|"### m##########m * ######____________d### ,d############b.* #####~P-.|##PL-._"#### d################b* `###| |"' )##Pd##################.* "##| ,~\ -~`. |#P#####################* "#| | ;P #####################* `\ ^ ;/ #####################* \ = / ############PT"PY"YnP)* \ .' ########Y##P;`_', #Y"`-.* ~--. .-' ########|Y7 ,~ ~ #|. `.* ` ~~ |\__ "#####7'-. #| \ \* .-/| |\\\~~--"#### ~ | _ #|` \ .* _.-~ : ; ,|.\ ~"##b .~/ /#| \ : `* .-~~ ' Tm..mm##|` "##b ~ /|#| :| \* . |#######| : "##`---.../ |#| || |* || ' |#######| ` "# ` ~#|..---. -~* ;| ; |#######| : Loo. | o'/ , \* '` \ |#######| |: .' ,d8888/\ 8~ ,8 . \* | . \ |#######| .'`. ; d8888888 : ,8 d' `. \* ` \` &gt; |#######|`-. || d88888888~' ,d8 d8 \ _\-'* | \. .-~ |#######| 7`|d888888888 ,' 8bo8L`\`.'|* ; | `. |#######| ; d888888888P,' d88888b\T |* ' | ' : |#######| ; Y888888""~~- Y8b8888 |* \; | |#######| : &lt;Y888~ |`. ddPd888 |* | | ` |#######| ; | YP |\\ 88d8888 |* | | : |#######| .' | ` _|`:.-Y88888 |* _L.--~| ` |#######| | | | _-~ - \ Y888bo. |* &lt; | : |#######| : ` `.,'--~ ` \ | `8P'~ \ |~~----.* | ` ` |#######|.' : |~ | ~ | `| |* | | :|#######|; | | | _.`. . |* `-----` `|#######|' \ , ' ---~ ,m &lt; ;* ' | |#######| \/ /mmmmmmmm###bmd#b '* | | |######"| ,' .d################# :* | |. |~~~T~ | ' ,################### '* | || | | | ' d####################b :* | ,|' | | | .' .d######################..'* | '| | | L.--~~ /########################b'* | : | | | ,'; '###""""""""""""""""######b* | ' | | | , / ; , _/###" "Yakamo &amp; Pai" "####* | , | | | || | : (~ | ## (from 3x3 Eyes) ###* ; | | `` ` | ' --- Dov Sherman*/ 小汽车来喽 1234567891011121314/** * _______________________________________________________* | |* / | |* /---, | |* -----# ==| | |* | :) # ==| | |* -----'----# | |______________________________________________________|* |)___() '# |______====____ \___________________________________|* [_/,-,\"--"------ //,-, ,-,\\\ |/ //,-, ,-, ,-,\\ __#* ( 0 )|===******||( 0 )( 0 )||- o '( 0 )( 0 )( 0 )||* ----'-'--------------'-'--'-'-----------------------'-'--'-'--'-'--------------*/ 我了个去、 这不是梦娜丽莎么？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** :';t)/!||||(//L+)'(-\\/ddjWWW#######WmKK(\!(/-|J=/\\t/!-/\!_L\) * |-!/(!-)\L\)/!\5(!.!LWW###################WK/|!\\\\/!;\/\T\/((\ * |!'//\//(-!t\Y/\L!m#####M####################WLt\\!)\/J-//)/;t\ * --/-.\.\/\.!)///m######K#######################WK!/!-( )-!,|/\ * //,\--`--!-/\(q#######DD##########################L\\\\-!!//!\\ * -.-!\'!!\-\/:W########N############################W,).'-.-/\-' * !.\!-!-!`!-!W#######P|+~**@@@#######################W/,/'\-/,\7 * --`,-- -/.:W###*P!' \`Z8#####################;,\\`,\,\* `.'.'\`-.-d##5'- -- '-:V@##########W#########_\-!-\\-* `, -,.'/,G##K- ' - )7KM###################\-----/* - '- --:##@; -!ZZ###################W! \'!- * '-.`- G###|. `,D8K###################|/-.-/ * -' ,-//###@) -)ZWMW##################\` _\* - ' .:Yd###! `-!(K5K##################|(/L| * - :\G###Z- ` ! -;55ZZ#################)(4) * . -!W####!\ ` ' !-tVG################XNVZ * tt####@-. ` ')(W################D)8@ * )8#####\ .-`-/KW#################KD# * ||Z####W!- .::,\.. -,;\bZKK######8#K#########(#8 * KN8#####( ,:!/GG_ d4KW8ZKW#WWK#W#88#######W##########WK# * )/8K###K#W#WP~~~T4( dW##7'___L#M####MM8W###W############bM8 * \!48#K####8##W*###WY; WRob+~~######*ff/\NM8###############WW# * .\\KW###W#,~t' !*~!', -M@) `~`,),' '.`K#################@KW * .'8M###### -'..j/Z'' @//- ,,\\+\' :|W######M###########8 * :\#8#K###D \!` !:Z8###8@#####8W#W###8M * q8W5###### `!- `-)8##################M8 * 8WZ8#M####- / . .\tK############@######ZJ * #W#@K###W#| // \\tW@###@K##W##W###K###Wm * ##8#M#8###P- -=/, /;D8W##############@###W## * #8###M@####\- , _)jJ; -((WKK#####W####W##K######K * ###W@K##K##); `\..KW##WK )X)KW#M##W###MW##@#W######8# * #K#W####@#@@/;- ~M####M\ ,.\\=)D8W##W###W##########8W##@ * ####MW######(`\\' PPK((.:|/!-\-/)8XN@WMK#######W##MK#@##### * ##8##MK#W#@#b!--\)L_. .(ZLWbW#\'- ,-N|/KM#######W###@########W# * ##KW###K#W###/- !``~~Yff*N5f -' -.\))KK#######MK##W###M8W#W### * #W###K@K######J-- .._dd/;)/- !//)NK#8W##########8########M#K * ##8W#K###W#####W!. `YY\)\\)\7(-)4dW#8#@###K#W#######8######## * M####8##K#KW###W#/, '-\\//)88W#M#@#K##M###@##M#8##@#W#8#M * ZW#W#M#K##########m -)!/LtWW#W##@#W#####KW#######W###K### * K##W#####W#M#8#####KL .-//dD##8W#K######8##########MK###W##M# * tN#W##W#W#M##########bb4dKW#@##W##K####MK####8###########W##### * )NM#8W##@###@##############@##@##8##K#W####M##K##K#@###8##M#### * (tMM###W##M8####@####@###@#########@####8W##8W################M * tNZ##K###W####@#####8###/4N##8#W##W##M#8#MK#M8#K######W######## * M/K@8###M@###M##########|!t*Z#N####8##M8Z@ZZ#M###@#W#####K###W# * WVd4M######@############D,\`(+KKZD#8WK#5@84VZ#WM############W## * K5WM8#8W#W########8######,,-!/))ZK5@K4)@+(/XV/Z###@###W###M#### * +8WN@##@K##W###W#########b.-.\!||\X(5)Z/7\\\t5/K########W###### * 8M8###@###@##8#########KDbt! !.-!t`(-\\!.\/.\!ZdG###W#MW###G### * ~~~~~`~~~~~~~~~~~~~~~~'~` '' ' ` ` ' ' ` ``~`~`~`~~~~'~~~~ */ 我喜欢朦胧美 12345678910111213141516171819202122232425262728293031323334353637/** ............HIIMHIMHMMHMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:.............* ...........MMMI:MII:MIHMHMMMMMHMMMMIMMMIMMMMMMMMMMMMMM.............* .........:MMMI:M::HM::MIHHHM:IM:MHM:IMH:IMMMIIMMMHMMMH:............* ........:MMMHHM::MMI:HH:MM:I:M:MMMH:IMH:IMM::MH:MM:MM:M............* .......MMMMHMM:MMIMHMII:MM:IIIM:MHMIMMM:MMIIH::MH:HM:M............* ...... :MIMMMMMMMMMHMMHMM:HHMHMMMMIMHMMMMHMHMIHIHM::MMI............* .......M:MMMMMMMMMMMMHMMMMMMMMHMMMMMMMMMMHMMMHMMIMHMMMM:...........* .......HHMMMMMMMMMMMMMMMMIMMMM.MMHMMMMHMMMMMMMMMMMIMHMMI...........* ........MMMIMMMMMMMMMMIHMIMIM:.M:HMM:MIHMMMMMMMMMMMMMMMI...........* ........MM.MMMMMMMMMMMH:MMMHM:.M.:MM.M.HMMMHMMMMMMMMMMMI...........* ........MM.MMMMMMMMMMH::M.M.M..M..MM:M.IIMH:MMMMMMMMMMMI...........* ........M:.MM:MMMMMMM:.I..:.I..H..IM:I.I.M.IMHMMMMMMMMMI...........* ........M..MMMHMMMMM.:HI:HHH......H....II..:MMMMMMMHMM:...........* ...........MM.MIMMMM.:H: .::I........ ...:IH:.MMMMMM:MMI...........* ...........:H..MMMIM.M.:...:I.........: ..::HHHMMMMIMMMH...........* ............H..IMM:I:..I:..:..........I:..:I:::MMMMMMMMM...........* ...............MMH::I...I:::..........III.I::MMMHMMMMMMM...........* ..............MMMHMII.. ..............:MI:I.HIIIHM:HMMMM...........* .............:MMMMIM::...........:......:H..:II:MHIMMMMM...........* .............MMMMMMMMM......................I.MMMHHMMMMM:..........* ............MMMMH:MMMMM........:.:.........:MMMMMMMMMMMMI..........* ...........MMMMMMHMMMMMMM.. .............:MMMMMMMMMMMMMMM..........* ........ .IMMMMMMMMMMMMMMMM............:MMMMMMMMMHMMMMMMM..........* ..........MMMMMMMMMMMMMMMMMI:.......:IHMMMMMMMMM::MMMMMMM..........* .........MMMMMMMIMMMMMMMMMMH:::I:I:.::HMMMMMMMMMHMMMMMMMMI.........* ........HMMMMMMM:MMMMMMMMMMI:::::::..:HMMMMMMMMIMMMMMMMMMM.........* .......IMMMMM..MI:MMMMMMMMM::::..:::::.MMMMMMMMMMMMMMMMMMM ........* ......:MMMM....:MMHMMMMMM:::::.....::.:.MMMMMMMHMMMMMMMMMM.........* ......MMI....:::IMMMMI:.:::::.....:I::::::HMMMHIM::::::MMMH........* .....MM.....:::IMIMMM:.......:....::::::::IMMHMM:I:::I:::MM .......* ....MMM.....:I:.MIHMMM........:...:::::::HMMMMI:::::....::M:.......* ...:MM:........:MMMHMM..................IMMMMM::...........M.......* ...MMM........:::MMMMM......:..........:HMMMMM::...................* ..:MM:.......:::::MMMM........... .. .::MMM:HM::.............:.....* ..MMM........:::::MMMMM:I..HHIMHMHHHM :IMMHIMH::.............I....*/ 美女啊、 小心口水… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// nHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHn.// .MS?MMMMMMMMMMMMMMMMMM?MM~MMMMMMMMMSHMMMMMMMM(?"~\// MMMMMH?MMMMMMMX*MM?MMX%MM/MMMMMM"HMMMMMMMMMMMMMMH// MMMMMMMMMMMMMMMMMX*MX*MMMX?MMMMM(M!XMMMMMMMMMMMMMMMX// XMC)?MMMMMMMMMMMMMMMhX?!?MMMMX#MM!MXMMMMMMMMMMMML '~// '\ MMMMMMMMMMMMMMMMMMMMMMMM!~`````-`~!?MMMM)MMMMMMMMx// `~""MMM)MMMMMMMMMMMMMMMHhHH!~ `#MM(MMMMMMMMMM&gt;// HM!HMMMMMMMMMMMMMMMM*?)?` `"MMMMMMMMMX .// XM!MMMMMMMMMMMMMMMMMMM?~ 'MMMMMMMM:..xx!`// M!MMMMMMMMMMMMMMMMMXH! MMMMXMMP"`// \!MMMMMMMSMHHHMM?XMM?~ -:::xx.. M?XMM?".x(// MXMMMMMMMMMM!XHMMMM": ... `"%x XHHHMMM*"// \!MMMMMMMM?XMMMMMMX!'~L '%%%+:. ` ..MMMMM"// 'HMMMMMM?HMMMMM*XM! h ~\).^\~ .%""`MM?"// 'MMMMMMMMMMMMMXMMM! -X +%%!.MMMXk// ?MMMMMMMMMMMXMMMMM `. ~ `""'XMMMMX// !MMMMMMMMMMMMMMMMMX. ' XMkMMX&gt;// XMMMMMMMMMMMMMMM?MXXXx.-` XXMMM!// MMMMMMMMMMMMMMMMXMXXXXXXx. ~~ MMMMM// XMMMMMMMMMMMM?MMXXXXXXXXX!` '+^ .MMM!P// 'MMM!MMMMMMMMMi?M!"` `~%HHHHxx. xMMMM"// :MMMMMMMMMMMMMMM" `\XMM .MMMMM// XMMMMMMMMMX?MM! `( HMMMMM// XMMMM)MMM" \~ 'MMMMM*// 'MMMMfMMM" \~ XMMM*// .MMMMMXMM" ^ `MMM// XMMMM!MM" MM&gt;// HMMMMXM~ MM&gt;// ?MMMMM~ Xf%// MMMMf %% \// 4MMM %// `M %// % %// % %// % ! %// % ! %// % % !?%.// % % X. %%.// % % X! %%.// % % '! %.// % % !! %.// % % '! `%// % % !&gt; /%// % % !! % %// % % ! \%// % % !! %// % % '! %~// % % !! %~// %% % `! %%// %%% % %++4MMf// ?MMx % %. MMX// *MMMx % !\'MMM&gt;// MMMMMHx .....xxnH %HMMM&gt;// MMMMMMMMMMMMMMMMMMM&gt; MMMMX// 'MMMMMMMMMMMMMMMMMMk 'MMMM// 'MMMMMMMMMMMMMMMMMM MMMM&gt;// ?MMMMMMMMMMMMMMMMMM 'MMMX// MMMMMMMMMMMMMMMMMMM MMMM// XMMMMM 小猪猪 12345678910111213141516171819// _,--. ,--._// \ &gt; `|&gt;o&lt;|' &lt; /// `-. .-'// / 'e___e` \// ( (o o) )// _\_ `=' _/_// / /(`-._.-')\ \// / / `.___,' \_\// _/ / _____ \ \_// / _(_,--' `--._)_ \// `' )______@______( `'// hjw / \// /_________________\// \ )( /// \ / \ /// ) | | (// /`-'] [`-'\// `--' `--'// 丘比特之剑 1234567891011121314151617// (// .-'''-..' \ Who the...??// _______ .' - \ yikes!// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; );__ ,,,_) \ __ /// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ) ;C / \ /ZZZ' )// &lt;&lt;&lt;&lt;&lt;&lt; (.-'-. )====_)_=======&gt; .-'``'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;// &lt;&lt;&lt;&lt;&lt; \ ''''''' ) .' &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;// ; &lt;&lt;&lt; .......__/ __\_; ,&gt;&gt;&gt;&gt;&gt;&gt;&gt;// .-''' ( ) / / ('"\__// .-' ;. / (;/;) /\// / .-' . = . /// _-''\_/ '. .' . /// .-' ) ;\ '''. . /// ; .'''' `. ' ; (// O -' .''' .' (__)))// .' .-'''''` ( )mikey(__)))// 'o-' ( _))(_ _)( _))_)) 我在看你 1234567891011121314151617181920212223242526272829303132// _______________________________// ,;:::::::|:::::|::::::|::::::::::|:;// ,' ###l;;;;;;|;;;;;|;;;;;;;|;####l;;;;// ; ###l; ;;;; ;;; ;;;;; ####l;;|;;;// `. ###l ;;; ;; ;;; ####l;|;:|;;// : ; + ; + ;; ;; ;|::|;// | + ++++++ ;::|::;// : + ~~~~~~~~~' `. ;||;;;// ; + ` ;::::|;// ,' ;|;||;;// ,' ____ ____ ;;~~ ;`;;;;|;// `,-' __`-,;;;;;,:____`-. ~~~ ;; ____ ;// `.--'(o)~`; ::`. (o)~; `` ~~ ,',--,)// `---~ ,' ```:`--~-;;~~`` ,',' ;,'// / `~~~ ,' :`~~~~~ ,' :,' ;;``.// `.__ .' __` \______,/ :( ;) ))// ;~~ ; '~~` ~~~~~~ \_&#125; ;,'// ,' .' _____) ,' \_ ;'~,'// : `.__ ' . . \ : ///\__,'// `. / .. :. . . .\ : //// : ` \___`_____\ .; : // :// `. ,---`'----,\ ; ,' / ;// \ (~~`~~'~~~) ` ,' ,-'// : `---------' ,' _,-'// `. " _,'_,-' \______// : ~~ _,'--' ; (______()// `._________; ; ' : ~~~~~~// ; |`. '/ ` ;| \ _// _,-' |:::`-. ,;:| \ `-._// ,-' |::::::`-----------':::/ : `--.// , -' |::::::::::::::::::::::/ : `// :::::::::::::::::::::::/ : 佛祖保佑 123456789101112131415161718192021// _ooOoo_ // o8888888o // 88" . "88 // (| -_- |) // O\ = /O // ____/`---'\____ // . ' \\| |// `. // / \\||| : |||// \ // / _||||| -:- |||||- \ // | | \\\ - /// | | // | \_| ''\---/'' | | // \ .-\__ `-` ___/-. / // ___`. .' /--.--\ `. . __ // ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". // | | : `- \`.;`\ _ /`;.`/ - ` : | | // \ \ `-. \_ __\ /__ _/ .-` / / // ======`-.____`-.___\_____/___.-`____.-'====== // `=---=' // // ............................................. // 佛祖保佑 永无BUG 标注键盘 12345678910111213141516/** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 骷髅头 123456789101112131415161718192021222324/** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-" "-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; "=._ | )(__/ \__)( | _.=" &lt; | * * | (_/"=._"=._ |/ /\ \| _.="_.="\_) | * * | "=._"(_ ^^ _)"_.=" | * * | "=\__|IIIIII|__/=" | * * | _.="| \IIIIII/ |"=._ | * * | _ _.="_.="\ /"=._"=._ _ | * * | ( \_.="_.=" `--------` "=._"=._/ ) | * * | &gt; _.=" "=._ &lt; | * * | (_/ \_) | * * | | * * '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=' * * * * LASCIATE OGNI SPERANZA, VOI CH'ENTRATE * ************************************************************** */ 神兽保佑 1234567891011121314151617// ┏┓ ┏┓// ┏┛┻━━━┛┻┓// ┃ ┃ // ┃ ━ ┃// ┃ ┳┛ ┗┳ ┃// ┃ ┃// ┃ ┻ ┃// ┃ ┃// ┗━┓ ┏━┛// ┃ ┃ Code is far away from bug with the animal protecting // ┃ ┃ 神兽保护，永无BUG！// ┃ ┗━━━┓// ┃ ┣┓// ┃ ┏┛// ┗┓┓┏━┳┓┏┛// ┃┫┫ ┃┫┫// ┗┻┛ ┗┻┛ 1234567891011121314151617181920212223/** * ┏┓ ┏┓+ + * ┏┛┻━━━┛┻┓ + + * ┃ ┃ * ┃ ━ ┃ ++ + + + * ████━████ ┃+ * ┃ ┃ + * ┃ ┻ ┃ * ┃ ┃ + + * ┗━┓ ┏━┛ * ┃ ┃ * ┃ ┃ + + + + * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ + 神兽保佑,永无bug * ┃ ┃ * ┃ ┃ + * ┃ ┗━━━┓ + + * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ + + + + * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛+ + + + */ 是不是很炫酷、 喜欢请拿走吧、转载请注明出处哦~~~ 更多内容请参考如下地址： http://www.asciiworld.com/-Halloween,58-.html]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>代码注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop 搭建常用命令记录]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%B7%A5%E5%85%B7%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[idea 快捷键 搜索工具 ctrl+j ： 搜索代码 ctrl+l: 跳转到第多少行 ctrl+shift+R: 查找代码 ctrl+H: 查找内容 定位代码 ctrl+shift+数字 ： 添加/删除书签 ctrl+数字 ： 跳转到指定书签 代码中添加 //TODO 注释, 下次接着写代码，可以很快定位到这个位置 ctrl+e: 打开最近浏览的文件窗口 ctrl+n ： 弹出菜单 ctrl+F8: 添加或删除当前行断点 ctrl+home: 跳到文件头 ctrl+end: 跳到文件尾 ctrl+del: 删除光标后面的内容 ctrl+左键； 跳到引用地址 ctrl+方向键： 移动光标 alt+上下方向键： 移动当前代码行到停止处 shift+end: 选中光标到行尾 shift+home: 选中光标到行头 ctrl+alt+v: 快速提取变量，声明变量 ctrl+alt+t ： 弹出包含代码界面，if,else,try,catch等 ctrl+alt+y: 选中相同值，同步更改 ctrl+alt+enter: 光标所在行上空一行，并将光标移到该行 ctrl+alt+F7: 弹出该变量所有被调用的地方 ctrl+shift+u: 选中内容转大小写 ctrl+shift+F7: 高亮显示所有相同内容 ctrl+shift+空格： 智能代码提示 代码提示 ctrl+alt+o: 删除错误导入包 alt+enter: 导入单个包 关闭窗口 ctrl+shift+w： 关闭所有打开的窗口文件 ctrl+F4: 关闭当前编辑文件 ctrl+w： 关闭项目目类页面 ctrl+shift+F12： 编辑器最大化 ctrl+table: 切换窗口 alt+左右方向键： 切换当前打开文件窗口视图 alt+数字： 切换选项卡 代码补全等 ctrl+F3: 展示当前类 存在多少方法， 参数和返回值和类型等 alt+ ins: 代码自动生成， 如get, set , toString等 窗口展示 alt++` ： 显示git移交弹框 alt+F12: 显示命令窗口，输入npm命令 alt+F1: 显示当前文件显示在哪个目标弹出层 shift+ F3: 弹出一个简化的显示代码的窗口， 不显示各种功能界面 shift+ F11: 弹框书签栏 格式化 ctrl+alt+l : 格式化代码 ctrl+shift+f: 格式化代码 ctrl+shift+j: 自动将下一行合并到当前行末尾 alt+shift+上下方向键： 扩大当前选中内容]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%B7%A5%E5%85%B7%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git命令 git帮助 1234查看帮助： git help看指定命令： git help clone搜索关键字： /clone 【翻页：f 下一页 , B上一页】退出文档： Q 常用操作 克隆原程仓库到本地仓库： git clone 仓库地址 当前文件夹下面 同步到服务器不用每次输入密码： git config --global credential.helper cache 创建分支，切换分支： git branch testing , git checkout testing 新建分支并将当前分支内容同步到新建分支： git checkout -b test1 查看项目分叉历史： git log --oneline --decorate --graph --all 将新建分支修改内容同步到master： 先 git checkout master , 在 git merge test2 – 如果两者有共同修改的文件， 使用git status 会看到，然后使用vi 命令操作之后，在使用git add , git commit -m ‘注释’ 一遍即可 从服务器其拉取数据和分支， 然后制动合并更新： git pull , 相当于 git fetch test1 ; git merge test2 将test1分支合并到master分支： git rebase master test1 分支合并后，删除无用分支： git branch -d test1 本地移交命令 初始化git本地仓库： git init 查看文件状态： git status 新建文件添加【颜色变绿】： git add 文件名 – 添加多个文件到git : git add . – 提交： git commit -m “注释” 文件从暂存区提交到git： git commit 文件名 -m “提交时文件备注” 红色文件是没有git管理的文件 ，绿色文件： 文件加入到了暂存区 红色文件是没有git管理的文件 ，绿色文件： 文件加入到了暂存区 查看日志： git log 配置别名 git config --global alias.st “status” git reset --hard HEAD^ --》一个^代表回退一个版本； git reset --hard 99899ss[代表版本号]； 查看每一步操作，日志记录： git reflog 初始化服务器： git init --bare 多人合作开发 初始化服务器： git init --bare 克隆代码： git clone /User/dream/desktop/project 去gitHub 搜索.gitignore ，然后找到oc的忽略文件去gitHub 搜索.gitignore ，然后找到oc的忽略文件 拷贝所有内容，来到终端 echo -e&quot;(com + V 输入粘贴内容)&quot; &gt; .gitignore 保证.gitignore 跟.git 在同一目录下 （.git 这个目录是git管理的目录） 将.gitignore 推送给远程服务器 add / commit / push (一定要在创建项目之前) 推送本地分支代码给服务器： git push 推送本地分支代码给服务器： git push 新人加入之前，一定要配置账号，否则默认全局，而且要在commit 之前配置账号信息 拿到最新代码： git pull 初始化下载代码： $ git clone https://github.com/libgit2/libgit2 （mylibgit2）自定义文件夹名 检出分支并同时切换到该分支： git checkout -b iss53 删除远程服务器上的文件 123git rm --cached -r usermkdirgit commit -m 'remove dirctory from remote repository'git push 常见报错或问题 git pull 报错： fatal : refusing to merge unrelated histories 1解决方案： git pull origin master --allow-unrelated-histories 解决git merge 分支名 或者 git checkout 分支名 时报错：error: the following untracked working tree files would to overwritten by checkout 1解决方案： git clean -d -fx '.idea/workspace.xml' 常用的一些命令记录 123456789101112131415161718git remote --vgit remote --hgit push -u mor --allgit pull mor mastergit commit -a -m '注释' ：一步提交git checkout -b user1git rm git mv 重明名git diffgit branch -a tree -agit merge usergit remote add origin 仓库地址git remote rename origin originold git reset --hard 版本号git push -f如果已经建立了远程分支uat，自己本地也建立了一个uat， 那么可以使用下面这条命令关联两个仓库git branch --set-upstream-to=origin/uat uat 1.本地修改了文件（没有git.add的文件），放弃修改： git checkout . 2.本地新增了文件（没起有git.add的文件），想放弃新增： 单个文件， rm filename / rm dir -rf 所有文件夹 git clean -xdf *如果文件已经已经git add到暂存区，并不会删除！ 3.已经git add到暂存区，想放弃修改： git reset HEAD . 4.本地已经git add 和git commit 之后想要撤销此次操作的 (撤销之后，你所做的commit修改还在工作区！) git reset commit_id 查看commit_id git log 撤销之后，你所做的commit修改将会清除，仍在暂存区的不会清除： git reset --hard commit_id]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用博客]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%B7%A5%E4%BD%9C%2F%E5%AE%9E%E7%94%A8%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[https://me.idealli.com/post/2d5da13e.html hexo 调优]]></content>
      <categories>
        <category>外部链接</category>
      </categories>
      <tags>
        <tag>博文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Java读后感]]></title>
    <url>%2F2019%2F08%2F20%2F%E4%B9%A6%E7%B1%8D%2FEffective%20Java%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[builder类经典创建方式]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
</search>
